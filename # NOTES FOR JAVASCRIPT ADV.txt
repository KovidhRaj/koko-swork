# NOTES FOR JAVASCRIPT FULL AND ADVANCED #

1) VARIABLES

NOTE: JAVASCRIPT IS PROGRAMMING LANGUAGE THAT ALLOWS TO CHANGE ANY DATA TYPE DURING
RUN TIME AND SUCH LANGUAGES ARE CALLED OR SAID TO BE DYNAMICALLY TYPED PROGRAMING LANGUAGE.

let a = 90;
console.log(a);
a = "kovidhraj";
console.log(a);


var a = 99; // BECAUSE OF VAR THIS WILL THROW AN ERROR AS THIS ONE IS DEDICATED TO GIVE ONLY 
INTEGER VALUE TO THE VARIABLE "a" HENCE THROWS THE ERROR.

console.log(a);
let a = 90;
console.log(a);
a = "kovidhraj";
console.log(a);

2) VAR, LET AND CONST USED IN JAVASCRIPT !!! 


var a = 90;
var b = "kovidh";
// YOU CAN EITHER PUT IT WITH LET OR VAR BUT IT WILL GIVE OUTPUT AS

GOOD
KOVIDH

{
    let b = "good";
    console.log(b);
}

console.log(b);

// BUT THIS PART WILL THROW AN ERROR

var a = 90;
const b = "kovidh";

{
    var b = "good";
    console.log(b);
}

console.log(b);

// VAR CAN BE RE-DECLARED WHILE LET OR CONST CANNOT BE RE-DECLARED 

//
var is globally scoped while let and const are block scoped.

var can be updated & re-declared within its scope.

let can be updated but not re-declared.

const can neither be updated nor be re-declared.

var variables are initialized with undefined whereas let and const variables are not initialized.

const must be initialized during declaration unlike let and var.

//

3) PRIMITIVES AND OBJECTS IN JAVASCRIPTS

These are 7 primitive datatypes in JavaScript:

Null
Number
String
Symbol
Undefined
Boolean
BigInt

// nn bb ss u

let a = null;
let b = 345;
let c = true;
let d = BigInt("442") + BigInt("3");
let e = "Kovidh";
let f = Symbol("i am ironman");

console.log(a,b,c,d,e,f);

console.log(typeof a);

// OBJECTS IN JAVASCRIPT 



const item = {
    "Kovidh": true,
    "gauri": false,
    "Lovish": 67,
    "tina": undefined
}
console.log(item["Kovidh"]);
console.log(item["gauri"]);
console.log(item["tina"]);
console.log(item["Lovish"]);


const a = {

    name:"Kovidh",
    age: 20
}
// a = 90;

a['friend'] = "mohit";
a['friend2'] = "neil";

console.log(a);

4) EXPRESSIONS AND OPERATORS

## OPERATORS ##

a) ARITHMETIC OPERATORS


let a = 90;
let b = 2;

console.log("a + b =", a + b);
console.log("a - b =",a-b);
console.log("a * b =",a*b);
console.log("a / b =",a/b);
console.log("a ** b =",a**b);
console.log("a % b =", a%b);

post increment and pre increment

console.log("a++:",a++);
console.log("a:",a);

console.log("++a:",++a);
console.log("a:",a);

post decrement and pre decrement

console.log("a--:",a--);
console.log("a:",a);

console.log("--a:",--a);
console.log("a:",a);

b) ASSIGMENT OPERATOR

=

x=y

+=

x=x+y

-=

x=x-y

*=

x=x*y

/=

x=x/y

%=

x=x%y

**=

x=x**y

c) COMPARISON OPERATORS

a = 8;
b = 6;

console.log("a == b is",a == b);
console.log("a != b is",a != b);
console.log("a === b is",a === b);
console.log("a !== b is",a !== b);
console.log("a >= b is",a >= b);
console.log("a <= b is",a <= b);
console.log("a < b is",a < b);
console.log("a > b is",a > b);


==

Equal to

!=

Not equal

===

Equal value and type

!==

Not equal value or not equal type

> 

Greater than

< 

Less than

>=

Greater than or equal to

<=

Less than or equal to

?

Ternary operator

5) CONDITIONAL OPERATORS IN JAVASCRIPT

let a = prompt("what is your age?")
if(a > 20){
    alert("great you can drive");
}
else{
    alert("no you can not drive!!");
}


if (condition){
  // block of code if condition true
 }
else {
  // block of code if Condition false
}


if (age>0){
  console.log(“A valid age”);
}
else if (age>10 && age<15){
  console.log(“but you are a kid”);
}
else if (age>18){
  console.log(“Not a kid”);
else{
  console.log(“Invalid Age”);
}


## Javascript ternary operator ## 
Evaluates a condition and executes a block of code based on the condition.

Condition ? exp1 : exp2

Example syntax of ternary operator looks like this:

(marks >10) ? ‘Yes’ : ’No’ 
// if marks are greater than 10, you are passed else not

// HOMEWORK IS TO EXPLORE THE SWITCH CASE IN JAVASCRIPT

switch (expression) {
    case value1:
        // Code to execute if expression === value1
        break;
    case value2:
        // Code to execute if expression === value2
        break;
    // Add more cases as needed
    default:
        // Code to execute if none of the above cases match
}


6) FOR LOOPS IN JAVASCRIPT

let a = 5;

for(let i = 0;i < 10;i++){
    console.log("a x i = ",a*i);
}


let sum = 0;
let n = prompt("enter the number");
for(let i=0;i<n;i++){
    sum += (i+1);
}
console.log("sum of first "+ n +" natural number is "+ sum);


let marks = {
    kovidh:79,
    Raja:40,
    Mohit:80,
    Neil:77
}
for(let i=0;i<Object.keys(marks);i++){
    console.log("the marks of " + Object.keys(marks)[i] +"are" + marks[Object.keys(marks)[i]])
}


 ## The for-in loop ##

The syntax of for-in loop looks like this:

for (key in object){
//code to be executed
}

let marks = {
    kovidh:79,
    Raja:40,
    Mohit:80,
    Neil:77
}
for(let i in marks){
        console.log(i);
}


 ## The for-of loop ##

The syntax of for-of loop looks like this,

for (variable of iterable){
//code
}
// Iterable data structure like arrays, strings, etc.

7) WHILE LOOPS IN JAVASCRIPT

let a = 5;
let i = 3;
while(i < a){
    console.log(i);
    i++;
}

 ## DO WHILE LOOPS ##
let a = 7;
let i = 0;
do{
    console.log(i);
    i++;
}
while(i < a);

8) FUNCTIONS IN JAVASCRIPT

function addAvg(x,y){
    return 1 + (x+y)/2;
}

let a = 4;
let b = 2;
let c = 6;

console.log("average plus one have a value of ",addAvg(a,b));
console.log("average plus one have a value of ",addAvg(b,c));
console.log("average plus one have a value of ",addAvg(c,a));


Function invocation is a way to use the code inside the function. 

A function can also return a value. The value is returned back to the caller.

const sum = (a,b) => {
let c = a+b;
return c;    // returns the sum
}

// Above way or method can also be used to create and use the function

let y = sum(1,3);
consolge.log(y);    // prints 4

9) STRINGS IN JAVASCRIPT


let name = "Kovidhraj"
console.log(name);
console.log(typeof name);
console.log(name.length);


let boy1 = "kovidhraj";
let boy2 = "Neil";

let sentence = `${boy1} is friend of ${boy2}`
console.log(sentence);

NOTE:	
## Template literals use backticks instead of quotes to define a string. ##

## ESCAPE SEQUENCE ##
If you try to print the following string, JavaScript will misunderstand it 

let name = ‘Adam D’ Angelo’
We can use single quote escape sequence to solve the problem,

let name = ‘Adam D\’ Angelo’


1. length method
let name = “Harry”
name.length     // prints 5
 

2. toUpperCase() method
let name = “Harry”
name.toUpperCase()    // prints HARRY
 

3. toLowerCase() method
let name = “Harry”
name.toLowerCase()    // prints harry
 

4. slice method
let name = “Harry”
name.slice (2,4)    // prints rr (from 2 to 4, 4 not included)

//Indexing starts from 0, so H is 0, a is 1 and so on.
 

let name = “Harry”
name.slice(2)        // prints rry (from 2 to end)
 

5. replace method
let name = “Harry Bhai”
let newName = name.replace(“Bhai”, “Bhau”)
 

6. concat method
let name1 = “Harry”
let name2 = “Naman”
let name3 = name1.concat(name2, “Yes”)
// We can even use + operator for concatenation
 

7. trim method
let name = “      Harry     ”
let newName = name.trim()    // Removes whitespaces
 

Strings are immutable. In order to access the character at an index we use the following syntax,

let name = “Harry”
name[0]    // Prints H
name[1]    // Prints a


10) ARRAYS in JAVASCRIPT

Arrays are variables which can hold more than one value.

const fruits = [“banana”, “apple”, “grapes”]
const a1 = [7,”Harry”,false]    //can hold different type of data
 

Accessing Values
let numbers = [1,2,7,9]
numbers[0] – 1
numbers[1] – 2
 

Finding the length
let numbers = [1,7,9,21]
//Indexing start from 0, so 1 has 0 index value and 7 has 1 index value and so on.

numbers[0] - 1
numbers.length – 4
 

Changing the values
let numbers = [7,2,40,9]
numbers[2] = 8
// “numbers” now becomes [7,2,8,9]
 

 

Arrays are mutable
Array can be changed
In JavaScript, arrays are objects. The typeof operator on arrays returns object.
Const n = [1,7,9]
typeof n     // returns object

// Arrays can hold many values under a single name.


There are some important array methods in JavaScript. Some of them are as follows:

 

1. toString() - Converts an array to a string of comma separated values.
let n = [1,7,9]
n.toString()     // 1,7,9
 

2. join() – joins all the array elements using a separator.
let n = [7,9,13]
n.join(“ ”)    // 7-9-13
 

3. pop() – removes last element from the array.
let n = [1,2,4]
n.pop()        // updates the original array and returns the popped value
 

4. push() – Adds a new element at the end of the array.
let a = [7,1,2,8]
a.push(9)    // modifies the original array and returns the new array length
 

5. shift() – Removes first element and returns it.

6. unshift() – Adds element to the beginning. Returns new array length.

7. delete – Array elements can be deleted using the delete operator.
let d = [7,8,9,10]
delete d[1]    // delete is an operator
 

8. concat() – used to join array to the given array.
let a1 = [1,2,3]
let a2 = [4,5,6]
let a3 = [9,8,7]
a1.concat(a2,a3)    // Returns [1,2,3,4,5,6,9,8,7]
// concat returns a new array and does not change the existing arrays
 

9. sort() – sort() method is used to sort an array alphabetically.
let a = [7,9,8]
a.sort()        // a changes to [7,8,9] – sort method modifies the original array
sort() takes an optional compare function. If this function is provided as the first argument, the sort() function will consider these values (the values returned from the compare function) as the basis of sorting.

 

10. splice() – splice can be used to add new items to an array.
const numbers = [1,2,3,4,5]
numbers.splice(2,1,23,24)
//here, 2 is the position to add, 1 depicts the no. of elements to remove, and 23, 24 are the elements of be added.
splice method returns deleted items, and modifies the array.

 

11. slice() – slices out a piece from an array. It creates a new array.
const num = [1,2,3,4]
num.slice(2)        // [3,4]
num.slice(1,3)        // [2,3]
 

12. reverse() – Reverses the elements in the source array.


Arrays can be looped through using the classical JavaScript for loop or through some other methods discusses below.

 

1. forEach loop – calls a function, once for each array element.
const a = [1,2,3]
a.forEach((value,index,array) => {
    // function logic
});
 

2. Array.from – used to create an array from any other object.
Array.from(“Harry”)
 

3. for … of – for-of loop can be used to get the values from an array.
4. for … in – for-in loop can be used to get the keys from an array.


Map, Filter & Reduce in JavaScript

1. map() – creates a new array by performing some operation on each array element.
const a = [1,2,3]
a.map((value, index, array) => {
    return value*value;
})
 

2. filter() – Filters an array with values that passes a test. Creates a new array.
const a = [1,2,3,4,5]
a.filter(greater_than_5)
 

3. reduce method – Reduces an array to a single value.
const n = [1,8,7,11]
let sum = numbers.reduce(add)
// add is a function, so sum will get the sum of 1+8+7+11
# GUESS THE NUMBER GAME BY JAVASCRIPT

function randomNum(min,max){
    return Math.floor(Math.random()*(max - min + 1)) + min;
}
let num = parseInt(prompt("enter the number to be guessed between 1 to 100"),10);
let chances = 0;
let randomnumbers = randomNum(1,100);
while(num !== randomnumbers){
    if(num < randomnumbers){
        console.log("very low ranged try something new");
    }
    else if(num > randomnumbers){
        console.log("very high ranged try to keep it low");
    }
    chances++;
    num = parseInt(prompt("Enter another number"),10);
}
console.log(`You have guessed the correct number: ${randomnumbers}`);
console.log(`It took you ${chances} attempts`);


JavaScript in the Browser


JavaScript was initially created to make web pages alive. JS can be written right in a web page’s HTML to make it interactive.

The browser has an embedded engine called the JavaScript engine or the JavaScript runtime.

 

JavaScript’s ability in the browser is very limited to protect the user’s safety. For example, a webpage on http://google.com cannot access http://codeswear.com and steal information from there.

 

Developer tools
Every browser has some developer tasks which makes a developer’s life a lot easier.

F12 on chrome opens Dev tools.

 

Elements (All HTML Elements)

Console (All the errors + logs)

Network (All network requests)
 

 

We can also write JavaScript commands in the console.

12) JavaScript Script Tag

The script tag is used to insert JS into an HTML page.

The script tag can be used to insert external or internal scripts,

<script>
	alert(“Hello”)
</script>
// or…
<script src = “/Js/file.js”> </script>
 

The benefit of a separate JS file is that the browser will download it and store it in its cache.

13) JavaScript Console Object

The console object has several methods, log being one of them. Some of them are as follows:

assert() – used to assert a condition
clear() – clears the console
log() – outputs a message to the console
table() – Displays a tabular data
warn() – used for warnings
error() – used for errors
info() – used for special information
 

You will naturally remember some or all of these with time.

Comprehensive list can be looked up on MDN

13) JavaScript alert, prompt & confirm

alert: Used to invoke a mini window with a msg.

alert("hello")
 

prompt: Used to take user input as string.

inp = prompt("Hi", "No")
// Here No is the optional default value
 

confirm: Shows a message and waits for the user to press ok or cancel. Returns true for ok and false for cancel.

 

The exact location and look is determined by the browser which is a limitation.

14) DOM, BOM & Window Object

We have the following when JavaScript runs in a browser,

Window:

DOM
BOM
JavaScript Core
 

Window object represents browser window and provides methods to control it. It is a global object.

 

Document Object Model (DOM)
DOM represents the page content as HTML.

document.body    // Page body as JS Object

document.body.style.background="green"    
//It changes page background to green
 

Browser Object Model (BOM)
The Browser Object Model (BOM) represents additional objects provided by the browser (host environment) for working with everything except the document.

The functions alert/confirm/prompt are also a part of the BOM

location.href = "https://codewithharry.com"    // Redirect to another URL


EXERCISE 2 == SNAKE,WATER AND GUN

SNAKE---->BEATS----->WATER
WATER---->BEATS----->GUN
GUN------>BEATS----->SNAKE

Generate a Random Index
Use Math.random() to generate a random number and map it to an index in the array.

Math.random() generates a random number between 0 (inclusive) and 1 (exclusive).
Multiply this value by the length of the choices array to get a range between 0 and choices.length (exclusive).
Use Math.floor() to round the value down to the nearest integer (since array indices are whole numbers).


function Randomattack(min,max){
    return Math.floor(Math.random()*(max-min+1))+min;
}
let Count = 0;
let Count2 = 0;
let PlayAgain = true;
while(PlayAgain){
    let PlayerChoice = Number.parseInt(prompt("Choose any thing from Snake ,Water and Gun"));
    let ComputerChoice = Randomattack(0,2);
    const Choice = {Snake:0,Gun:1,Water:2};
    if((PlayerChoice === 2 && ComputerChoice === 1) || (PlayerChoice === 1 && ComputerChoice === 0) || (PlayerChoice === 0 && ComputerChoice === 2)){
        alert("Player has Won");
        Count++;
    }
    else if(PlayerChoice === ComputerChoice){
        alert("ITS A TIE!!");
    }
    else{
        alert("Computer has Won");
        Count2++;
    }
    PlayAgain = confirm("Do you Want to play Again?");
}
console.log(`Number of times Player has won ${Count}`);
console.log(`Number of times Computer has won ${Count2}`);


15) Walking the DOM

DOM tree refers to the HTML page where all the nodes are objects. There can be 3 main types of nodes in the DOM tree:

text nodes
element nodes
comment nodes
 

In an HTML page, <html> is at the root and <head> and <body> are its children, etc.

A text node is always a leaf of the tree.

 

Auto correction
If an erroneous HTML is encountered by the browser, it tends to correct it. For example, if we put something after the body, it is automatically moved inside the body. Another example is <table> tag which must contain <tbody>

 

Walking the DOM


 

Note: document.body can sometimes be null if the JavaScript is written before the body tag.

16) Accessing Children of an Element 


Children of an element
Direct as well as deeply nested elements of an element are called its children.

Child nodes -> Elements that are direct children. For example, head and body are children of <html>

Descendant nodes -> All nested elements, children, their children and so on …

 

firstChild, lastChild & childNodes
element.firstChild -> first child element
element.lastChild -> last child element
element.childNodes -> All child nodes
 

Following is always true:

elem.childNodes[0] === elem.firstChild
elem.childNodes[elem.childNodes.length-1] === elem.lastChild
 

There is also a method elem.hasChildNodes() to check whether there are any child nodes.

Note: childNodes looks like an array. But its not actually an array but a collection. We can use Array.from(collection) to convert it into an Array.    (Array methods won’t work)

## Parents & Siblings of an Element ##

DOM Collections
They are read-only
They are live elem.childNodes variable (reference) will automatically update if childNodes of elem is changed.
They are iterable using for…of loop.
 

Siblings and the parent
Siblings are nodes that are children of the same parent.

For example: <head> and <body> are siblings. Siblings have same parent. In the above example its html.
<body> is said to be the “next” or “right” sibling of <head>. <head> is said to be “previous” or “left” sibling of <body>
The next sibling is in nextSibling property, and the previous one in previousSibling.
 

The parent is available as parentNode.

alert(document.documentElement.parentNode);    //document

alert(document.documentElement.parentElement);    // null

## Element only Navigation ##


Sometimes, we don’t want text or comment nodes. Some links only take Element nodes into account, For example

document.previousElementSibling    // Previous sibling which is an Element

document.nextElementSibling        // next sibling Element

document.firstElementChild        // first Element child

document.lastElementChild        // last Element child

17) Table Navigation 

Table links
Certain DOM elements may provide additional properties specific to their type for convenience.

 

Table element support the following properties,

table.rows        // collection of tr elements
table.caption    // reference to <caption>
table.tHead    // reference to <thead>
table.tFoot    // reference to <tfoot>
table.tBodies    // Collection of <tbody> elements
tbody.rows    // Collection of <tr> inside

tr.cells            // Collection of td and th
tr.sectionRowIndex    // Index of tr inside enclosing element
tr.rowIndex         // Row number starting from 0

td.cellIndex    // no of cells inside enclosing <tr>
 

Quick Quiz: Print typeof document and typeof window in the console and see what it prints.

18) Searching the DOM

DOM navigation properties are helpful when the elements are close to each other. If they are not close to each other, we have some more methods to search the DOM.

 

document.getElementById

This method is used to get the element with a given “id” attribute

let span = document.getElementById(“span”)
span.style.color = “red”
 

document.querySelectorAll - Returns all elements inside an element matching the given CSS selector.

document.querySelector - Returns the first element for the given CSS Selector. A efficient version of elem.querySelectorAll(CSS)[0]

document.getElementsByTagName - Returns elements with the given tag name

document.getElementsByClassName (Don’t forget the “s” letter) - Returns elements that have the given CSS class. 

document.getElementsByName - Searches elements by the name attribute.

## matches, closest and contains ##

There are three important methods to search the DOM

 

1) elem.matches(CSS) – To check if element matches the given CSS selector

2) elem.closest(CSS) – To look for the nearest ancestor that matches the given CSS-selector. The elem itself is also checked.

3) elemA.contains(elemB) – Returns true if elemB is inside elemA (a descendant of elemA) or when elemA==elemB.

20) innerHTML, outerHTML and other properties

console.dir function

console.log shows the element DOM true.

console.dir shows the element as an object with its properties.

 

tagName / nodeName

Used to read tag name of an element.

tagName – only exists for Element nodes

nodeName – defined for any node (text, comment, etc)

 

innerHTML and outerHTML

The innerHTML property allows to get the HTML inside the element as a string. (valid for element nodes only)
The outerHTML property contains the full HTML, innerHTML + the element itself.
innerHTML is valid only for element nodes. For other node types we can use nodeValue or data.
 

textContent

Provides access to the text inside the element: only text, minus all tags.

 

The hidden property

The “hidden” attribute and the DOM property specifies whether the element is visible or not. 

<div hidden> I am hidden </div>
<div id = “element”> I can be hidden </div>

<script>
element.hidden = true;
</script>

21) HTML Attributes and their methods

Attribute methods
elem.hasAttribute(name) – Method to check for existence of an attribute.
elem.getAttribute(name) – Method used to get the value of an attribute.
elem.setAttribute(name,value) – Method used to set the value of an attribute.
elem.removeAttribute(name) – Method to remove the attribute from elem.
elem.attributes – Method to get the collection of all attributes.
 

data– attributes
We can always create custom attributes but the ones starting with “data-” are reserved for programmers use. They are available in a property named dataset.  

If an element has an attribute named “data-one”, its available as element.dataset.one

22) HTML Insertion Methods

We looked at some ways to insert elements in the DOM. Here is another way:

let div = document.createElement(‘div’)    //create
div.className = “alert”    //set class
div.innerHTML = “<span> hello </span>”
document.body.append(div)
 

Here are some more insertion methods:

node.append(e) – append at the end of node
node.prepend(e) – insert at the beginning of node
node.before(e) – insert before node
node.after(e) – insert after node
node.replaceWith(e) – replaces node with the given node
 

Quick Quiz: Try out all these methods with your own webpage.

23) insertAdjacentHTML, insertAdjacentElement and insertAdjacentText


insertAdjacentHTML/Text/Element
This method is used to insert HTML. The first parameter is a code word, specifying where to insert. Must be one of the following:

“beforebegin” – Insert HTML immediately before element
“afterbegin” – Insert HTML into element at the beginning
“beforeend” – Insert HTML into element at the end
“afterend” – Insert HTML immediately after element
The second parameter is an HTML string.

 

Example:

<div id=”div”> </div>
<script>
    div.insertAdjacentHTML(‘beforebegin’ , ’<p> Hello </p>’);
    div.insertAdjacentHTML(‘afterend’ , ’<p> Bye </p>’);
</script>
The output would be:

<p> Hello </p>
<div id = “div”> </div>
<p> Bye </p>
 

Node removal
To remove a node, there’s a method node.remove()

let id1 = document.getElementById(“id1”)
id1.remove()

24) Changing HTML Classes using JavaScript: className and classList

className and classList
If we assign something to elem.className, it replaces the whole string of classes.

 

Often, we want to add/remove/toggle a single class.

elem.classList.add/remove(“class”) – Adds/removes a class
elem.classList.toggle(“class”) – Adds the class if it doesn’t exist, otherwise removes it.
elem.classList.contains(“class”) – checks for the given class, returns true/false.

25) setInterval and setTimeout in JavaScript

setTimeout and setInterval:
setTimeout allows us to run a function once after the interval of time.

Syntax of setTimeout is as follows:

let timerId = setTimeout(function, <delay> (in ms), <agr1>, <arg2> )
(Above line returns the timerId)
 

clearTimeout is used to cancel the execution (in case we change our mind). For example:

let timerId = setTimeout( ()=> alert(“never”), 1000);
clearTimeout(timerId)    // cancel the execution
 

setInterval method has a similar syntax as setTimeout:

let timerId = setInterval(function, <delay>, <arg1>, <arg2>);
 

All arguments have the same meaning. But unlike setTimeout, it runs the function not only once, but regularly after the given interval of time.

To stop further calls, we can use clearInterval(timerId);

26) Introduction to Browser Events 

An event is a signal that something has happened. All the DOM nodes generate such signals.

Some important DOM events are:

Mouse events: click, context menu(right click), mouseover/mouseout, mousedown/mouseup, mousemove
Keyboard events: keydown and keyup
form element events: submit, focus, etc.
Document events: DOMContentLoaded
 

Handling Events
Events can be handled through HTML attributes

<input value = “Hey” onclick=”alert(‘hey’)” type=”button”>
// Instead of alert(“hey”), we can write another JS function.
Events can also be handled through the onclick property,

elem.onclick = function(){
            alert(“yes”)
            }
 

Note: Adding a handler with JS overwrites the existing handler.

27) Handling Browser Events

addEventListener and removeEventListener
addEventListener is used to assign multiple handlers to an event.

element.addEventListener(event, handler)
element.removeEventListener(event, handler)
// handler must be the same function object for this to work
 

The Event Object
When an event happens, the browser creates an event object, puts details into it and passes it as an argument to the handler

elem.onclick = function(event){
    …
}

event.type: Event type
event.currentTarget: Element that handled the event
event.clientX/ event.clientY: Coordinates of the cursor

28) Introduction to Callbacks


Asynchronous actions are the actions that we initiate now and they finish later. E.g. setTimeout 

Synchronous actions are the actions that initiate and finish one-by-one.

 

Callback functions
A callback function is a function passed into another function as an argument, which is then invoked inside the outer function to complete an action.

Here is an example of a callback:

function loadScript(src, callback){
	let script = document.createElement(‘script’)
	script.src = src
	script.onload = () => callback(script)
	document.head.append(script)
}
 

Now we can do something like this:

loadScript(‘https://cdn.harry.com’, (script) => {
	alert(‘script is loaded’)
	alert(script.src)
});
 

This is called “callback.based” style of async programming. A function that does something asynchronously should provide a callback argument where we put the function to run after its complete.

 

Handling errors
We can handle callback errors by supplying error argument like this:

function loadScript(src, callback){
	…
	…
	script.onload = () => callback(null,script);
	script.onerror = () => callback(new Error(‘failed’));
	…
}
 

Then inside of loadScript call:

loadScript(‘cdn/harry’, function(error, script)){\
	…
	if(error){
		// handle error
}
else{
	// script loaded
}
});

## Callback Hell & Pyramid of Doom ##

Pyramid of Doom
When we have callback inside callbacks, the code gets difficult to manage.

loadScript((…){
	loadScript ..			// Pyramid of Doom
		loadScript ..
			loadScript ..
				…
As calls become more nested, the code becomes deeper and increasingly more difficult to manage, especially if we have real code instead of …

This is sometimes called “callback hell” or “pyramid of doom”

The “pyramid” of these calls grows towards the right with every asynchronous action. Soon it spirals out of control. So this way of coding isn’t very good!

29) Introduction to Promises


 

The solution to the callback hell is promises. A promise is a “promise of code execution”. The code either executes or fails, in both the cases the subscriber will be notified.

The syntax of a Promise looks like this:

let promise = new Promise(function(resolve, reject){	
	// executor
});
// here resolve and reject both are predefined in JS engine
 

resolve and reject are two callbacks provided by JavaScript itself. They are called like this:

resolve(value) – If the job is finished successfully
reject(error) – If the job fails
 

The promise object returned by the new Promise constructor has these properties:

state: Initially pending, then changes to either “fulfilled” when resolve is called or “rejected” when reject is called
result – Initially undefined, then changes to value if resolved (resolve(value)) or error when rejected (reject(error)).

30) Promise .then() and .catch() 

Consumers: then & catch
The consuming code can receive the final result of a promise through then & catch

The most fundamental one is then

promise.then(function(result){*/handle */},
	function(error) {/* handle error */}
);
 

If we are interested only in successful competitions, we can provide only one function argument to .then():

let promise = new Promise (resolve => {
	setTimeout(() => resolve (“done”), 1000);
});

promise.then(alert);
 

If we are interested only in errors, we can use null as the first argument: .then(null, f) or we can use catch:

promise.catch(alert)
promise.finally(()=> {}) is used to perform general cleanups
 

Quick Quiz: Rewrite the loadScript function we wrote in the beginning of this chapter using promises.

31) Promise Chaining .then() calls

We can chain promises and make them pass the resolved values to one another like this,

p.then(function(result) => {		// p is a promise
	alert(result); return 2;
	}).then …
 

The idea is to pass the result through the chain of .then handlers.

 

Here is the flow of execution

1) The initial promise resolves in 1 seconds (Assumption)

2) The next .then() handler is then called, which returns a new promise (resolved with 2 value)

3) The next .then() gets the result of previous one and this keeps on going
Every call to .then() returns a new promise whose value is passed to the next one and so on. We can even create custom promises inside .then()

## Attaching Multiple Handlers to a Promise ##

We can attach multiple handlers to one promise. 

They don’t pass the result to each other; instead they process it independently.

 

Let p is a promise

p.then(handler 1)
p.then(handler 2)
p.then(handler 3)
// All of the above promises run independently

32) The Promise API

Promise API
There are 6 static methods of Promise class:

1) Promise.all(promises) – Waits for all promises to resolve and returns the array of their results. if any one fails, it becomes the error and all other results are ignored.
2) Promise.allSettled(promises) – Waits for all the promises to settle and returns their results as an array of objects with status and value.
3) Promise.race(promises) – Waits for the first promise to settle and its result/error becomes the outcome.
4) Promise.any(promises) – Waits for the first promise to fulfill (& not rejected), and its result becomes the outcome. Throws AggregateError if all the promises are rejected.
5) Promise.resolve(value) – Makes a resolved promise with the given value.
6) Promise.reject(error) – Makes a rejected promise with the given error.
 

Quick Quiz – Try all these promise APIs on your custom promises.

33) Async/Await in JavaScript

Async/Await
There is a special syntax to work with promises in JS.

A function can be made async by using async keyword like this:

async function harry(){
	return 7;
}
 

An async function always returns a promise. Other values are wrapped in a promise automatically.

We can do something like this:

harry().then(alert)
So, async ensures that the function returns a promise and wraps non promises in it.

 

The await keyword
There is another keyword called await that works only inside async functions

let value = await promise;
The await keyword makes JS wait until the promise settles and returns its value.

 

Its just a more elegant syntax of getting the promise result than promise .then and it’s easier to read and write.

34) Error Handling: try and catch

We all make mistakes. Also, sometimes our script can have errors. Usually, a program halts when an error occurs.

The try… catch syntax allows us to catch errors so that the script instead of dying can do something more reasonable.

 

The try… catch syntax
The try catch syntax has two main blocks:

try and then catch

try {
	// try the code
} catch(err) {			// The err variable contains an error object
	// error handling
}
 

It works like this

First the code in try is executed
If there is no error, catch is ignored else catch is executed
 

try catch works synchronously

If an exception happens in scheduled code, like in setTimeout, then try… catch won’t catch it:

try {
	setTimeout(function(){
		//error code		// script dies and catch won’t work
	}
catch …
 

That’s because the function itself is executed later, when the engine has already left the try … catch construct.

35) The Error Object & Custom Errors

The error object
For all the built-in errors, the error object has two main properties:

try {
	hey; 	//error variable not defined
} catch(err) {
	alert(err.name)
	alert(err.message)
	alert(err.stack)
}
 

Throwing custom Error
We can throw our own error by using the throw syntax

if(age>180){
    throw new Error(“Invalid Age”)
    …
 

We can also throw a particular error by using the built-in constructor for standard errors:

let error = new SyntaxError(message)
        or
            new ReferenceError(message)


36) The Finally Clause 

The finally clause
The try… catch construct may have one more code clause: finally

If it exists it runs in all cases:

after try if there were no errors
after catch if there were errors
 

If there is a return in try, finally is executed just before the control returns to the outer code.


## Exercise 4:
Create a Digital Seconds clock using setInterval and Date object in JS.

The Date object can be used to get the date, time, hours and seconds which can be then be updated using setInterval.

Try to keep the UI good looking.

 

Solution:
 

index.html file

<!DOCTYPE html>
<html>

<head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width">
        <title>replit</title>
        <link href="style.css" rel="stylesheet" type="text/css" />
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet"
                integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi"
                crossorigin="anonymous">

</head>

<body>
        <div class="text-center fs-1 text">
                <div class="badge bg-primary text-wrap text-center" id="time"></div>
        </div>
        <script src="script.js"></script>

        <!--
  This script places a badge on your repl's full-browser view back to your repl's cover
  page. Try various colors for the theme: dark, light, red, orange, yellow, lime, green,
  teal, blue, blurple, magenta, pink!
  -->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js"
                integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3"
                crossorigin="anonymous"></script>

        <script src="https://replit.com/public/js/replit-badge.js" theme="blue" defer></script>
</body>

</html>
 

script.js file

function getDateTime() {
        var now = new Date();
        var year = now.getFullYear();
        var month = now.getMonth() + 1;
        var day = now.getDate();
        var hour = now.getHours();
        var minute = now.getMinutes();
        var second = now.getSeconds();
        if (month.toString().length == 1) {
                month = '0' + month;
        }
        if (day.toString().length == 1) {
                day = '0' + day;
        }
        if (hour.toString().length == 1) {
                hour = '0' + hour;
        }
        if (minute.toString().length == 1) {
                minute = '0' + minute;
        }
        if (second.toString().length == 1) {
                second = '0' + second;
        }
        var dateTime = year + '/' + month + '/' + day + ' ' + hour + ':' + minute + ':' + second;
        return dateTime;
}

// example usage: realtime clock
setInterval(function() {
        currentTime = getDateTime();
        document.getElementById("time").innerHTML = currentTime;
}, 1000);
 

style.css file

html, body {
  height: 100%;
  width: 100%;
        background: #5a99dd !important;
}

37) Fetch API

Fetch API
fetch is used to get data over the network

let promise = fetch(url, [options])    //without options, a get request is send
 

Getting a response is a 2-stage process.

1. An object of Response class containing “status” & “ok” properties

    status – The http status code, Eg: 200

    ok – Boolean, true if the HTTP status code is 200-299

2. After that we need to call another method to access the body in different formats:

    response.text() – Read & return the text

    response.json() – parse the response as JSON

 

Other methods include response.formData(), response.blob(), response.arrayBuffer() etc.

Note – We can use only one body reading method.

Example if we have already got the response with response.text() then response.json() won’t work.

 

Response headers
The response headers are available in response.headers


Request headers
To set a request header in fetch, we can use the headers option.

let res = fetch(url, {
		headers: {
			Authentication: ‘Secret’
			}
		});

## POST requests ##
To make a POST request, we need to use fetch options

method – HTTP-method, e.g POST
body – the request body
 

let response = await fetch(‘/url’,{
			method: ‘POST’,
			headers: {
				‘Content Type’: ‘application/json’
				},
			body: ‘{“a”: ”harry”}’
	});

let result = await response.json()

38) Cookies in JavaScript

JavaScript Cookies
Cookies are small strings of data stored directly in the browser

In JS, document.cookie provides access to cookies.

Cookies are set by a web server using the Set-Cookie HTTP-header. Next time when the request is sent to the same domain, the browser sends the cookie using the cookie HTTP-header.
That way the server knows who sent the request

 

We can also access cookies using document.cookie property:

alert(document.cookie)
		// Contains key=value pairs delimited by ;
 

Writing to cookie
An assignment to document.cookie is treated specially in a way that a write operation doesn’t touch other cookies.

document.cookie = “user = Harry”
// updates only cookie named user to Harry
Quick Quiz: Print all the cookies on twitter.com

 

encodeURIComponent
This function helps keep the valid formatting. It is used like this:

document.cookie = encodeURIComponent(name) + ‘=’ + 
            encodeURIComponent(value)

// This way, the special characters are encoded
 

Cookie options
Cookies have several options which can be provided after key=value to a set call like this:

document.cookie = “user=John; path=/a; expires=Tue,29 March 2041 03:18:22 GMT”

// path option makes the cookie visible at /a, /a/b etc. expires sets the cookie expiration time.
 

Note:

1) The name=value pair, after encodeURIComponent, should not exceed 4KB
2) Total no of cookies per domain is limited to around 20+ (Exact number is browser dependent)

39) localStorage & related methods

localStorage
localStorage is a web storage object which are not sent to server with each request.

This data survives a full page refresh and even a full browser restart.

 

There are the method provided by localStorage

setItem(key, value) – Store key/value pair
getItem(key) – get the value by key
removeItem(key) – remove the key with its value
clear() – delete everything
key(index) – get the key on a given position
length – the number of stored items
 

We can get and set values like an object

localStorage.one = 1
alert(localStorage.one)
delete localStorage.one
 

Important Note

Both key and values must be strings
We can use the two JSON methods to store objects in localStorage:
JSON.Stringify(object)    //Converts objects to JSON Strings
JSON.parse(String)         //Converts string to objects (must be a valid JSON)

40) sessionStorage & related methods

sessionStorage
Used less often than localStorage. Properties and methods are same as localStorage but:

1) The sessionStorage exists only within the current browser tab. Another tab with same page will have a different storage.
2) The data survives page refresh, but not closing/opening the tab.
 

Storage Event
When the data gets updated in localStorage or sessionStorage, storage event triggers with these properties:

1) key – The key
2) oldValue – Previous value
3) newValue – New value
4) url – Page URL
5) StorageArea – local or sessionStorage
 

We can listen the onstorage event of window which is triggered when updates are made to the same storage from the documents