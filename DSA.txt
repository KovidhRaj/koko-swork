### APPLICATION OF DATASTRUCTURE ###

1) ARITHMETIC POLYNOMIAL LINKED LIST

## PLEASE NOTE THAT SIMPLY CREATING A LINKED LIST WITHOUT ANY ORDER IS NOT
A GOOD OPTION WHEN THE TARGET IS TO PEFORM SOME ARITHEMATIC OPERATION ##

## IT WOULD BE BETTER IF THE POLYNOMIAL EXPRESSION IS SORTED IN DESCENDING ORDER OF THEIR
EXPONENTS ##

# insert function to build a polynomial using linked list #

struct node{
float coefficient;
int exponent;
struct node *link;

}

struct node* insert(struct node* head,float co,int ex)

struct node* temp;
struct node* newP = malloc(size of(struct node));
newP->coeff = co;
newP->expo = ex;
newP->link = NULL;


if(head == NULL || ex > head->expo){
newP->link = head;
head = newP;
}
else
{
temp = head;
while(temp->link != NULL && temp->link->expo > ex)
temp = temp->link;
newP->link = temp->link;
temp->link = newP;
}
return head;
}


struct node* create(struct node* head){
int n;
int i;
float coeff;
int expo;

printf("Enter the number of terms: ");
scanf("%d",&n);

for(i = 0;i<n;i++){

printf("enter the coefficient for term %d: ",i+1);
scanf("%f",&coeff);

printf("enter the exponents for term %d: ",i+1);
scanf("%f",&expo);

head = insert(head,coeff,expo);
}
return head;
}


void print(struct node* head){
if(head == NULL)
printf("No polynomial.");
else{
struct node* temp = head;
while(temp!=NULL){
printf("(%.1fx^%d)",temp->coeff,temp->expo);
temp = temp->link;
if(temp != NULL)
printf(" + ");
else
printf("\n");
}
}
}

int main(){
struct node* head = NULL;
printf("enter the polynomial\n");
head = create(head);
print(head);
return 0;
}


### APPLICATION OF LINKED LIST TO ADD THE TWO POLYNOMIALS ###

* In a linked list representation,the addition operation is easier to perform because the two polynomial represented by the linked list are arranged in descending order * 


algorithm:

Repeat the following until ptr1 or ptr2 becomes NULL

if(ptr->expo == ptr2->expo)
add the coefficient and insert the newly created node in the resultant linked list and make ptr1 and ptr2 point to the next nodes.

if(ptr1->expo > ptr2->expo)
Insert the node pointed by the ptr1 in the resultant linked list and make ptr1 point to the next node.

if(ptr1->expo < ptr2->expo)
Insert the node pointed by ptr2 in the resultant linked list and make ptr2 point to the next node.


code:


#include <stdio,h>
#include <stdlib.h>


struct node{
float coeff;
int expo;
struct node* link;
};

struct node* insert(struct node* head,float co,int ex)
{
struct node* temp;
struct node* newP = malloc(size of(struct node));
newP->coeff = co;
newP->expo = ex;
newP-<link = NULL;

if(head == NULL || ex > head->expo){
newP->link = head;
head = newP;
}
else
{
temp = head;
while(temp->link != NULL && temp->link->expo >=ex)
temp = temp->link;
newP->link = temp->link;
temp->link = newP;
}
return head;
}

struct node* create(struct node* head)
{
int n,i;
float coeff;
int expo;

printf("enter the number of terms: ");
scanf("%f",&n);

for(i=0;i<n;i++){

printf("enter the coefficient for term %d: ",i+1);
scanf("%d",&coeff);

printf("enter the exponent for term %d: ",i+1);
scanf("%d",&expo);

head = insert(head,coeff,expo);
}
return head;
}

void print(struct node* head)
{

if(head == NULL)
printf("No polynomial.");
else{
struct node* temp = head;
while(temp != NULL)
{
printf("(%.1fx^%d)",temp->coeff,temp->expo);
temp = temp->link;
if(temp!=null){
printf(" + ");
}
else{
printf("\n");
}
}
}

void polyAdd(struct node* head1,struct node* head2)
{
struct node* ptr1 = head1;
struct node* ptr2 = head2;
struct node* ptr3 = NULL;

while(ptr1 != NULL && ptr2 != NULL)
{
if(ptr1->expo == ptr2->expo){
head3 = insert(head3,ptr1->coeff+ptr2->coeff,ptr1->expo);
ptr1 = ptr1->link;
ptr2 = ptr2->link;
}
else if(ptr1->expo > ptr2->expo)
{
head3 = insert(head3,ptr1->coeff,ptr1->expo);
ptr = ptr->link;
}
else if(ptr1->expo < ptr2->expo)
{
head3 = insert(head3,ptr2->coeff,ptr2->expo);
ptr2 = ptr2->link;
}

}

while(ptr1 != NULL)
{

head3 = insert(head3,ptr1->coeff,ptr1->expo);
ptr1 = ptr1->link;

}

while(ptr2 != NULL)
{

head3 = insert(head3,ptr2->coeff,ptr2->expo)
ptr2 = ptr2->link;

}
printf("Added polynomial is ");
print(head);
}

int main(){
struct node* head1 = NULL;
struct node* head2 = NULL;
printf("enter the first polynomial\n");
head1 = create(head1);
printf("enter the second polynomial\n");
head2 = create(head2);

polyad(head1,head2);

return 0;
}


## APPLICATION OF LINKED LIST MULTIPLICATION OF TWO POLYNOMIALS ##


WE NEED TWO POINTER (PTR1 AND PTR2) FOR TRAVERSAL WE ALSO NEED A NESTED LOOP AS EACH
TERM OF THE FIRST POLYNOMIAL MUST BE MULTIPLIED WITH EVERY TERM OF THE SECOND POLYNOMIAL.

#include <stdio.h>
#include <stdlib.h>

struct node{
float coeff;
int expo;
struct node* link;
};
struct node* insert(struct node* head,float co,int ex){

struct node* temp;
struct node* newP = malloc(size of(struct node));
newP->coeff = co;
newP->expo = ex;
newP->link = NULL;

if(head == NULL || ex > head->expo){
newP->link = head;
head = newP;
}
else{
temp = head;
while(temp->link != NULL && temp->link->expo >= ex)
temp = temp->link;
newP->link = temp->link;
temp->link = newP;

}
return head;

}
struct node* create(struct node* head)
{
int n,i;
float coeff;
int expo;
printf("enter the number of terms: ");
scanf("%d",&n);

for(i=0;i<n;i++){

printf("enter the coefficient for term %d: ",i+1);
scanf("%f",&coeff);

printf("enter the exponent for term %d: ",i+1);
scanf("%d",&expo);

head = insert(head,coeff,expo);
}
return head;
}

void print(struct node* head){

if(head == NULL)
printf("no polynomial");
else{
struct node* temp = head;
while(temp != NULL){
printf("(%.lfx^%d)",temp->coeff,temp->expo);
temp = temp->link;
if(temp != NULL){
printf(" + ");

} 
else{

printf("\n");


}

}

}

void polyMult(struct node* head1,struct node* head2)
{
struct node* ptr1 = head1;
struct node* ptr2 = head2;
struct node* head3 = NULL;

if(head1 == NULL || head2 == NULL){
printf("zero polynomial\n");
return;
}
while(ptr1 != NULL)
{
while(ptr2 != NULL)
{
head3 = insert(head3,ptr1->coeff * ptr2->coeff,ptr->expo + ptr2->expo);
ptr2 = ptr2->link;
}
ptr1 = ptr1->link;
ptr2 = head2;

}
print(head3);

}

int main(){

struct node* head1 = NULL;
struct node* head2 = NULL;
printf("enter the first polynomial\n");
head1 = create(head1);
printf("enter the second polynomial\n");
head2 = create(head2);

polyMult(head1,head2);
return 0;
}


int res1,res2;
struct node *head3 = NULL;
while(ptr1 != NULL){
while(ptr2 != NULL){

res1 = ptr1->coeff * ptr2->coeff;
res2 = ptr1->expo + ptr2->expo;
head3 = insert(head3,res1,res2);
ptr2 = ptr2->link;


}

}

## RADIX AND BUCKET SORT ##


## BUCKET SORT ##

The basic procedure of performing the bucket sort is given as
follows -
• First, partition the range into a fixed number of buckets.
• Then, toss every element into its appropriate bucket.
• After that, sort each bucket individually by applying a
sorting algorithm.
• And at last, concatenate all the sorted buckets.


## RADIX SORT ##

In Radix sort,
• Digit by digit sorting is performed started from the least
significant digit to the most significant digit.



• Radix Sort Steps
• First, find the largest element (suppose max) from the
given array. Suppose 'x' be the number of digits in max.
• The 'x' is calculated because we need to go through
the significant places of all elements

• After that, go through one by one each significant place.
Here, we have to use any stable sorting algorithm to sort
the digits of each significant place.



• Algorithm
Radix Sort (arr)

Max = largest element in the given array
D = number of digits in the largest element (or, max)
Now, create D buckets of size 0 - 9
for i -> 0 to D
sort the array elements using stable sorting algorithm
according to the digits at the ith place.

## SPARSE MATRIX REPRESENTATION USING LINKEDE LIST ##

Matrix
 A two-dimensional data object made of m rows and n
columns, have total m x n values

Sparse Matrix
 Most of the elements of the matrix have 0 value
 Example:
0 0 3 0 4
0 0 5 7 0
0 0 0 0 0
0 2 6 0 0

Why to use Sparse Matrix instead of simple matrix?

 Storage
 There are lesser non-zero elements than zeros and thus
lesser memory can be used to store only those elements

 Computing time
 Computing time can be saved by logically designing a data
structure traversing only non-zero elements

Representing a sparse matrix by a 2D array
 Leads to wastage of lots of memory as zeroes in the
matrix are of no use in most of the cases

 Instead of storing zeroes with non-zero elements, we
only store non-zero elements
 i.e. store non-zero elements with triples-(Row, Column,
Value)


## ARRAY REPRESENTATION ##

Array Representation of Sparse Matrix
 2D array is used to represent a sparse matrix in which
there are three rows named as
 Row: Index of row, where non-zero element is located
 Column: Index of column, where non-zero element is located
 Value: Value of the non zero element located at index –
(row, column)

## LINKED LIST REPRESENTATION ##

Linked List Representation of Sparse Matrix
 In linked list, each node has four fields
 Row: Index of row, where non-zero element is located
 Column: Index of column, where non-zero element is located
 Value: Value of the non zero element located at index –
(row, column)
 Next node: Address of the next node


List of Lists Representation of Sparse Matrix
 One list is used to represent the rows and each row
contains the list of triples: Column index, Value and
address field for non – zero elements


## PRIORITY QUEUE ##
** IF TWO ELEMENTS HAVE SAME PRIORITY THEN THEY ARE REMOVED OR EDITED ON THE BASIS OF
FIFO CONDITION **

# TYPES OF PRIORITY QUEUES #

Ascending order priority queue:
• A lower priority number is given as a higher priority in
a priority.
• For example, numbers from 1 to 5 arranged in an
ascending order like 1,2,3,4,5; therefore, the smallest
number, i.e., 1 is given as the highest priority in a
priority queue.

Descending order priority queue:
• A higher priority number is given as a higher priority in
a priority.
• For example, numbers from 1 to 5 arranged in
descending order like 5, 4, 3, 2, 1; therefore, the
largest number, i.e., 5 is given as the highest priority in
a priority queue

## CONTENTS OF BINARY SEARCH TREE ##

1) INSERTION IN BINARY SEARCH TREE

#include <stdio.h>
#include <stdlib.h>

// Definition of a Node
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Function to create a new Node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Function to insert a Node in the BST
struct Node* insert(struct Node* root, int data) {
    // If the tree is empty, return a new node
    if (root == NULL)
        return createNode(data);

    // Otherwise, recur down the tree
    if (data < root->data)
        root->left = insert(root->left, data);
    else if (data > root->data)
        root->right = insert(root->right, data);

    // Return the (unchanged) root pointer
    return root;
}

void printTree(struct node* root, int space) {
    if (root == NULL)
        return;

    // Increase distance between levels
    space += 5;

    // Process right child first
    printTree(root->right, space);

    // Print current node after spacing
    printf("\n");
    for (int i = 5; i < space; i++)
        printf(" ");
    printf("%d\n", root->data);

    // Process left child
    printTree(root->left, space);
}


// Inorder traversal of BST
void inorderTraversal(struct Node* root) {
    if (root != NULL) {
        inorderTraversal(root->left);
        printf("%d ", root->data);
        inorderTraversal(root->right);
    }
}

// Main function
int main() {
    struct Node* root = NULL;
    root = insert(root, 50);
    root = insert(root, 30);
    root = insert(root, 20);
    root = insert(root, 40);
    root = insert(root, 70);
    root = insert(root, 60);
    root = insert(root, 80);

    printf("Inorder traversal of the BST:\n");
    inorderTraversal(root);

    return 0;
}



2) DELETION IN BINARY SEARCH TREE

#include <stdio.h>
#include <stdlib.h>

// Definition of a Node
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Function to create a new Node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Function to insert a Node in the BST
struct Node* insert(struct Node* root, int data) {
    if (root == NULL)
        return createNode(data);

    if (data < root->data)
        root->left = insert(root->left, data);
    else if (data > root->data)
        root->right = insert(root->right, data);

    return root;
}

// Function to find the minimum value node in a BST
struct Node* findMin(struct Node* node) {
    struct Node* current = node;

    while (current && current->left != NULL)
        current = current->left;

    return current;
}

// Function to delete a Node from the BST
struct Node* deleteNode(struct Node* root, int key) {
    if (root == NULL)
        return root;

    // If the key to be deleted is smaller than the root's key
    if (key < root->data)
        root->left = deleteNode(root->left, key);
    // If the key to be deleted is greater than the root's key
    else if (key > root->data)
        root->right = deleteNode(root->right, key);
    else {
        // Node with only one child or no child
        if (root->left == NULL) {
            struct Node* temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            struct Node* temp = root->left;
            free(root);
            return temp;
        }

        // Node with two children: Get the inorder successor (smallest in the right subtree)
        struct Node* temp = findMin(root->right);

        // Copy the inorder successor's content to this node
        root->data = temp->data;

        // Delete the inorder successor
        root->right = deleteNode(root->right, temp->data);
    }
    return root;
}

// Inorder traversal of BST
void inorderTraversal(struct Node* root) {
    if (root != NULL) {
        inorderTraversal(root->left);
        printf("%d ", root->data);
        inorderTraversal(root->right);
    }
}

// Main function
int main() {
    struct Node* root = NULL;
    root = insert(root, 50);
    root = insert(root, 30);
    root = insert(root, 20);
    root = insert(root, 40);
    root = insert(root, 70);
    root = insert(root, 60);
    root = insert(root, 80);

    printf("Inorder traversal of the original BST:\n");
    inorderTraversal(root);

    printf("\n\nDeleting 20\n");
    root = deleteNode(root, 20);
    printf("Inorder traversal after deletion:\n");
    inorderTraversal(root);

    printf("\n\nDeleting 30\n");
    root = deleteNode(root, 30);
    printf("Inorder traversal after deletion:\n");
    inorderTraversal(root);

    printf("\n\nDeleting 50\n");
    root = deleteNode(root, 50);
    printf("Inorder traversal after deletion:\n");
    inorderTraversal(root);

    return 0;
}


# AVL TRESS, HEAP AND HEAPSORT, B-TREE AND MORE:

1) AVL TREE (INSERTION AND ROTATION)

ROTATE OPERATIONS:

# WE CAN PERFORM ROTATE OPERATION TO BALANCE A BINARY SEARCH TREE SUCH THAT THE NEWLY
FORMED TREE SATISFIES ALL THE PROPERTIES OF A BST. FOLLOWING ARE THE TWO BASIC ROTATE
OPERATION:

1) LEFT ROTATE WRT A NODE = NODE IS MOVED TOWARDS THE LEFT
2) RIGHT ROTATE WRT A NODE = NODE IS MOVED TOWARDS THE RIGHT.

# BALANCING A AVL TREE AFTER INSERTIONS

IN ORDER TO BALANCE AN AVL TREE AFTER INSERTION, WE CAN FOLLOW THE FOLLOWING RULES:

1) FOR LEFT-LEFT INSERTION = RIGHT ROTATE ONCE WRT THE FIRST IMBALANCED NODE.
2) FOR RIGHT-RIGHT INSERTION = LEFT ROTATE ONCE WRT THE FIRST IMBALANCED NODE.
3) FOR LEFT-RIGHT INSERTION = LEFT ROTATE ONCE THEN RIGHT ROTATE(RR) ONCE.
4) FOR RIGHT-LEFT INSERTION = RIGHT ROTATE ONCE THEN LEFT ROTATE(LL) ONCE.


CODE FOR AVL TREE:


#include <stdio.h>
#include <stdlib.h>

// Node structure
struct node {
    int key;
    struct node* left;
    struct node* right;
    int height;
};

// Function to get the height of a node
int getHeight(struct node* n) {
    if (n == NULL)
        return 0;
    return n->height;
}

// Function to get the maximum of two integers
int max(int a, int b) {
    return (a > b) ? a : b;
}

// Function to create a new node
struct node* createNode(int key) {
    struct node* newNode = (struct node*)malloc(sizeof(struct node));
    newNode->key = key;
    newNode->left = NULL;
    newNode->right = NULL;
    newNode->height = 1; // New node is initially added at leaf
    return newNode;
}

// Function to get the balance factor of a node
int getBalanceFactor(struct node* n) {
    if (n == NULL)
        return 0;
    return getHeight(n->left) - getHeight(n->right);
}

// Right rotation
struct node* rightRotate(struct node* y) {
    struct node* x = y->left;
    struct node* T2 = x->right;

    // Perform rotation
    x->right = y;
    y->left = T2;

    // Update heights
    y->height = max(getHeight(y->left), getHeight(y->right)) + 1;
    x->height = max(getHeight(x->left), getHeight(x->right)) + 1;

    // Return new root
    return x;
}

// Left rotation
struct node* leftRotate(struct node* x) {
    struct node* y = x->right;
    struct node* T2 = y->left;

    // Perform rotation
    y->left = x;
    x->right = T2;

    // Update heights
    x->height = max(getHeight(x->left), getHeight(x->right)) + 1;
    y->height = max(getHeight(y->left), getHeight(y->right)) + 1;

    // Return new root
    return y;
}

// Insertion function for the AVL tree
struct node* insertNode(struct node* node, int key) {
    // 1. Perform the normal BST insertion
    if (node == NULL)
        return createNode(key);

    if (key < node->key)
        node->left = insertNode(node->left, key);
    else if (key > node->key)
        node->right = insertNode(node->right, key);
    else
        return node; // Equal keys are not allowed in AVL tree

    // 2. Update the height of this ancestor node
    node->height = 1 + max(getHeight(node->left), getHeight(node->right));

    // 3. Get the balance factor of this ancestor node to check whether it became unbalanced
    int balanceFactor = getBalanceFactor(node);

    // 4. If the node becomes unbalanced, then there are 4 cases

    // Left Left Case
    if (balanceFactor > 1 && key < node->left->key)
        return rightRotate(node);

    // Right Right Case
    if (balanceFactor < -1 && key > node->right->key)
        return leftRotate(node);

    // Left Right Case
    if (balanceFactor > 1 && key > node->left->key) {
        node->left = leftRotate(node->left);
        return rightRotate(node);
    }

    // Right Left Case
    if (balanceFactor < -1 && key < node->right->key) {
        node->right = rightRotate(node->right);
        return leftRotate(node);
    }

    // Return the (unchanged) node pointer
    return node;
}

// Function to print the tree in order
void inorder(struct node* root) {
    if (root != NULL) {
        inorder(root->left);
        printf("%d ", root->key);
        inorder(root->right);
    }
}

int main() {
    struct node* root = NULL;

    // Insert nodes
    root = insertNode(root, 10);
    root = insertNode(root, 20);
    root = insertNode(root, 30);
    root = insertNode(root, 40);
    root = insertNode(root, 50);
    root = insertNode(root, 25);

    // Print in-order traversal of the AVL tree
    printf("Inorder traversal of the AVL tree: ");
    inorder(root);
    printf("\n");

    return 0;
}

2) DELETION OF NODE IN A AVL TREE:


#include <stdio.h>
#include <stdlib.h>

// Node structure
struct node {
    int key;
    struct node* left;
    struct node* right;
    int height;
};

// Function to get the height of a node
int getHeight(struct node* n) {
    if (n == NULL)
        return 0;
    return n->height;
}

// Function to get the maximum of two integers
int max(int a, int b) {
    return (a > b) ? a : b;
}

// Function to create a new node
struct node* createNode(int key) {
    struct node* newNode = (struct node*)malloc(sizeof(struct node));
    newNode->key = key;
    newNode->left = NULL;
    newNode->right = NULL;
    newNode->height = 1; // New node is initially added at leaf
    return newNode;
}

// Function to get the balance factor of a node
int getBalanceFactor(struct node* n) {
    if (n == NULL)
        return 0;
    return getHeight(n->left) - getHeight(n->right);
}

// Right rotation
struct node* rightRotate(struct node* y) {
    struct node* x = y->left;
    struct node* T2 = x->right;

    // Perform rotation
    x->right = y;
    y->left = T2;

    // Update heights
    y->height = max(getHeight(y->left), getHeight(y->right)) + 1;
    x->height = max(getHeight(x->left), getHeight(x->right)) + 1;

    // Return new root
    return x;
}

// Left rotation
struct node* leftRotate(struct node* x) {
    struct node* y = x->right;
    struct node* T2 = y->left;

    // Perform rotation
    y->left = x;
    x->right = T2;

    // Update heights
    x->height = max(getHeight(x->left), getHeight(x->right)) + 1;
    y->height = max(getHeight(y->left), getHeight(y->right)) + 1;

    // Return new root
    return y;
}

// Function to find the node with the minimum value (used for deletion)
struct node* findMinNode(struct node* node) {
    struct node* current = node;
    while (current->left != NULL)
        current = current->left;
    return current;
}

// Insertion function for the AVL tree
struct node* insertNode(struct node* node, int key) {
    // 1. Perform the normal BST insertion
    if (node == NULL)
        return createNode(key);

    if (key < node->key)
        node->left = insertNode(node->left, key);
    else if (key > node->key)
        node->right = insertNode(node->right, key);
    else
        return node; // Equal keys are not allowed in AVL tree

    // 2. Update the height of this ancestor node
    node->height = 1 + max(getHeight(node->left), getHeight(node->right));

    // 3. Get the balance factor of this ancestor node to check whether it became unbalanced
    int balanceFactor = getBalanceFactor(node);

    // 4. If the node becomes unbalanced, then there are 4 cases

    // Left Left Case
    if (balanceFactor > 1 && key < node->left->key)
        return rightRotate(node);

    // Right Right Case
    if (balanceFactor < -1 && key > node->right->key)
        return leftRotate(node);

    // Left Right Case
    if (balanceFactor > 1 && key > node->left->key) {
        node->left = leftRotate(node->left);
        return rightRotate(node);
    }

    // Right Left Case
    if (balanceFactor < -1 && key < node->right->key) {
        node->right = rightRotate(node->right);
        return leftRotate(node);
    }

    // Return the (unchanged) node pointer
    return node;
}

// Deletion function for the AVL tree
struct node* deleteNode(struct node* root, int key) {
    // 1. Perform standard BST deletion
    if (root == NULL)
        return root;

    if (key < root->key)
        root->left = deleteNode(root->left, key);
    else if (key > root->key)
        root->right = deleteNode(root->right, key);
    else {
        // Node with only one child or no child
        if ((root->left == NULL) || (root->right == NULL)) {
            struct node* temp = root->left ? root->left : root->right;

            // No child case
            if (temp == NULL) {
                temp = root;
                root = NULL;
            } else  // One child case
                *root = *temp; // Copy the contents of the non-empty child

            free(temp);
        } else {
            // Node with two children: Get the inorder successor (smallest in the right subtree)
            struct node* temp = findMinNode(root->right);

            // Copy the inorder successor's data to this node
            root->key = temp->key;

            // Delete the inorder successor
            root->right = deleteNode(root->right, temp->key);
        }
    }

    // If the tree had only one node then return
    if (root == NULL)
        return root;

    // 2. Update the height of the current node
    root->height = 1 + max(getHeight(root->left), getHeight(root->right));

    // 3. Get the balance factor of this node
    int balanceFactor = getBalanceFactor(root);

    // 4. If this node becomes unbalanced, then there are 4 cases

    // Left Left Case
    if (balanceFactor > 1 && getBalanceFactor(root->left) >= 0)
        return rightRotate(root);

    // Left Right Case
    if (balanceFactor > 1 && getBalanceFactor(root->left) < 0) {
        root->left = leftRotate(root->left);
        return rightRotate(root);
    }

    // Right Right Case
    if (balanceFactor < -1 && getBalanceFactor(root->right) <= 0)
        return leftRotate(root);

    // Right Left Case
    if (balanceFactor < -1 && getBalanceFactor(root->right) > 0) {
        root->right = rightRotate(root->right);
        return leftRotate(root);
    }

    return root;
}

// Function to print the tree in order
void inorder(struct node* root) {
    if (root != NULL) {
        inorder(root->left);
        printf("%d ", root->key);
        inorder(root->right);
    }
}

int main() {
    struct node* root = NULL;

    // Insert nodes
    root = insertNode(root, 10);
    root = insertNode(root, 20);
    root = insertNode(root, 30);
    root = insertNode(root, 40);
    root = insertNode(root, 50);
    root = insertNode(root, 25);

    // Print in-order traversal of the AVL tree before deletion
    printf("Inorder traversal of the AVL tree before deletion: ");
    inorder(root);
    printf("\n");

    // Delete a node
    root = deleteNode(root, 30);

    // Print in-order traversal of the AVL tree after deletion
    printf("Inorder traversal of the AVL tree after deleting 30: ");
    inorder(root);
    printf("\n");

    return 0;
}




HEAP AND HEAPSORT:

DRY CODE FOR INSERTION:

void insert(A[],n,value){
n = n+1;
A[n] = value;
int i = n;
while(i > 1){
int parent = i/2;
if(a[parent] < a[i]){
swap(A,parent,i);
i = parent;
}
else{
return;
}
}
}

DRY CODE FOR DELETION:

void delete(A[],n){
A[1] = A[n];
n = n-1;
i = 1;
while(i < n){
int left = A[2*i];
int right = A[2*i+1];
int larger = left > right ? 2*i:2*i+1;
if(A[i] < A[larger]){
swap(A, i ,larger);
i = larger;
}
else{
return;
}
}
}

## HEAPIFY AND HEAPSORT ##

1) Heapify:

void heapify(int a[],int n,int i){
int largest = i;
int l = 2*i;
int r = 2*i+1;
if(l<=n && a[r] > a[largest]){
largest = l;
}
if(r <= n && a[r] > a[largest]){
largest = r;
}
if(largest != i){
swap(a,i,largest);
heapify(a,n,largest);
}
}

build heap(int a[],int n){
ofr(int i = n/2;i>0;i--){
heapify(a,n,i);
}
}


DRY CODE FOR HEAPSORT:

void heapsort(int a[],int n){
for(int i = n;i > 1;i--){
swap(a,1,i);
heapify(a,i-1,1);
}
}

FULL FLEDGE HEAP CODE:

#include <stdio.h>

void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// Function to heapify a subtree rooted at index `i`
void heapify(int arr[], int n, int i) {
    int largest = i;       // Initialize largest as root
    int left = 2 * i + 1;  // Left child index
    int right = 2 * i + 2; // Right child index

    // If left child is larger than root
    if (left < n && arr[left] > arr[largest])
        largest = left;

    // If right child is larger than largest so far
    if (right < n && arr[right] > arr[largest])
        largest = right;

    // If largest is not root
    if (largest != i) {
        swap(&arr[i], &arr[largest]);

        // Recursively heapify the affected sub-tree
        heapify(arr, n, largest);
    }
}

// Function to insert a new key into the heap
void insertHeap(int arr[], int* n, int key) {
    // Increase the size of the heap
    *n = *n + 1;
    int i = *n - 1;
    arr[i] = key;

    // Fix the max-heap property if it is violated
    while (i != 0 && arr[(i - 1) / 2] < arr[i]) {
        swap(&arr[i], &arr[(i - 1) / 2]);
        i = (i - 1) / 2;
    }
}

// Function to perform heap sort
void heapSort(int arr[], int n) {
    // Build the initial max heap
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);

    // Extract elements from heap one by one
    for (int i = n - 1; i >= 0; i--) {
        // Move the current root (max element) to the end
        swap(&arr[0], &arr[i]);

        // Call max-heapify on the reduced heap
        heapify(arr, i, 0);
    }
}

// Function to print an array
void printArray(int arr[], int n) {
    for (int i = 0; i < n; i++)
        printf("%d ", arr[i]);
    printf("\n");
}

int main() {
    int arr[100];  // Array to store heap elements
    int n = 0;     // Current size of heap

    // Insert elements into the heap
    insertHeap(arr, &n, 10);
    insertHeap(arr, &n, 20);
    insertHeap(arr, &n, 30);
    insertHeap(arr, &n, 40);
    insertHeap(arr, &n, 50);
    insertHeap(arr, &n, 25);

    // Print the heap before sorting
    printf("Heap before sorting: ");
    printArray(arr, n);

    // Perform heap sort
    heapSort(arr, n);

    // Print the sorted array
    printf("Sorted array: ");
    printArray(arr, n);

    return 0;
}



## B TREE AND B+ TREE ##

1) Multi-way Tree (m-way Tree):

Multiway search tree of order m (or an m-way search tree) is a m-way tree in which:

i) Each node has m children and m-1 key fields.
ii) The keys in each node are in ascending order
iii) The keys in the first i children are smaller than i(th) key.
iv) The keys in the last m-i children are larger than the i(th) key.


2) Definition of a B-tree:

i) A B-tree of order m is an m-way tree.
ii) No. of Keys(Non leaf node) = No. of children(its own) - 1
iii) All leaves are on the same level.
iv) All non-leaf nodes (except the root) have at least [m/2] children.
v) The root is either a leaf node or it has two to m children.

## CONSTRUCT A B-TREE OF ORDER 5 ##

Node properties:

Every node can have at most 4 keys and 5 children.
Every node (except the root) must have at least 2 keys.
The root must have at least 1 key.
The keys in a node are arranged in ascending order.


Balancing:

All leaves must be at the same level.
When a node is full (i.e., it has 
𝑚
−
1
m−1 keys, here 4 keys for order 5), it splits, and one key is promoted to the parent node.

## INSERTION OPERATION OF A B-TREE ##

Steps for Insertion:

1) Start by inserting keys sequentially.

2) If a node exceeds the maximum number of keys (i.e., 4 keys in this case for order 5), split the node.

3) Move the middle key up to the parent node.

4) Ensure the tree remains balanced.

CODE:

#include <stdio.h>
#include <stdlib.h>

#define ORDER 5

// Structure representing a B-tree node
struct BTreeNode {
    int keys[ORDER - 1];              // Array of keys
    struct BTreeNode* children[ORDER]; // Array of child pointers
    int numKeys;                       // Number of keys in the node
    int isLeaf;                        // 1 if the node is a leaf, 0 otherwise
};

// Function to create a new B-tree node
struct BTreeNode* createNode(int isLeaf) {
    struct BTreeNode* newNode = (struct BTreeNode*)malloc(sizeof(struct BTreeNode));
    newNode->isLeaf = isLeaf;
    newNode->numKeys = 0;  // Initially, no keys in the node
    for (int i = 0; i < ORDER; i++) {
        newNode->children[i] = NULL;  // Initialize child pointers to NULL
    }
    return newNode;
}

// Function to split a full child node
void splitChild(struct BTreeNode* parent, int i, struct BTreeNode* child) {
    struct BTreeNode* newNode = createNode(child->isLeaf);  // Create a new node for the split
    newNode->numKeys = ORDER / 2 - 1;                       // New node gets half the keys

    // Transfer the second half of the keys to the new node
    for (int j = 0; j < ORDER / 2 - 1; j++) {
        newNode->keys[j] = child->keys[j + ORDER / 2];
    }

    // Transfer the child pointers if it's not a leaf node
    if (!child->isLeaf) {
        for (int j = 0; j < ORDER / 2; j++) {
            newNode->children[j] = child->children[j + ORDER / 2];
        }
    }

    child->numKeys = ORDER / 2 - 1;  // Update the number of keys in the child node

    // Shift the parent's children to make space for the new node
    for (int j = parent->numKeys; j >= i + 1; j--) {
        parent->children[j + 1] = parent->children[j];
    }
    parent->children[i + 1] = newNode;

    // Move the middle key of the child to the parent
    for (int j = parent->numKeys; j >= i; j--) {
        parent->keys[j + 1] = parent->keys[j];
    }
    parent->keys[i] = child->keys[ORDER / 2 - 1];
    parent->numKeys++;  // Increment the number of keys in the parent
}

// Function to insert a new key into a non-full node
void insertNonFull(struct BTreeNode* node, int key) {
    int i = node->numKeys - 1;

    if (node->isLeaf) {
        // Insert the key into the leaf node
        while (i >= 0 && key < node->keys[i]) {
            node->keys[i + 1] = node->keys[i];
            i--;
        }
        node->keys[i + 1] = key;
        node->numKeys++;
    } else {
        // Find the child to insert the key into
        while (i >= 0 && key < node->keys[i]) {
            i--;
        }
        i++;

        // If the child is full, split it
        if (node->children[i]->numKeys == ORDER - 1) {
            splitChild(node, i, node->children[i]);
            if (key > node->keys[i]) {
                i++;
            }
        }
        insertNonFull(node->children[i], key);
    }
}

// Function to insert a new key into the B-tree
void insert(struct BTreeNode** root, int key) {
    struct BTreeNode* r = *root;

    // If the root is full, split it and create a new root
    if (r->numKeys == ORDER - 1) {
        struct BTreeNode* newNode = createNode(0);  // New root is not a leaf
        newNode->children[0] = r;
        splitChild(newNode, 0, r);
        insertNonFull(newNode, key);
        *root = newNode;  // Update the root pointer
    } else {
        insertNonFull(r, key);
    }
}

// Function to print the B-tree
void printBTree(struct BTreeNode* node, int level) {
    if (node != NULL) {
        int i;
        for (i = 0; i < node->numKeys; i++) {
            printBTree(node->children[i], level + 1);
            for (int j = 0; j < level; j++) {
                printf("    ");  // Indentation for levels
            }
            printf("%d\n", node->keys[i]);
        }
        printBTree(node->children[i], level + 1);
    }
}

int main() {
    // Create an empty root node (which is initially a leaf)
    struct BTreeNode* root = createNode(1);

    // Insert the keys into the B-tree
    int keys[] = {3, 7, 9, 23, 45, 1, 5, 14, 25, 24, 13, 11, 8, 19, 4, 31, 35, 56};
    int n = sizeof(keys) / sizeof(keys[0]);

    for (int i = 0; i < n; i++) {
        insert(&root, keys[i]);
    }

    // Print the B-tree
    printf("B-tree of order %d:\n", ORDER);
    printBTree(root, 0);

    return 0;
}

ANOTHER CODE:

// CODE PROVIDED BY THE CHATGPT

#include <stdio.h>
#include <stdlib.h>

#define ORDER 4  // ORDER should be 2 * t, where t is the minimum degree

// B-Tree node structure
struct BTreeNode {
    int keys[ORDER - 1];                 // Array of keys
    struct BTreeNode *children[ORDER];    // Array of children pointers
    int numKeys;                          // Current number of keys in the node
    int isLeaf;                           // 1 if leaf node, 0 if internal node
};

// Function to create a new B-tree node
struct BTreeNode *createNode(int isLeaf) {
    struct BTreeNode *newNode = (struct BTreeNode *)malloc(sizeof(struct BTreeNode));
    newNode->isLeaf = isLeaf;
    newNode->numKeys = 0;
    for (int i = 0; i < ORDER; i++) {
        newNode->children[i] = NULL;
    }
    return newNode;
}

// Function to split a full child node
void splitChild(struct BTreeNode *parent, int i, struct BTreeNode *child) {
    struct BTreeNode *newNode = createNode(child->isLeaf);
    int t = ORDER / 2;  // t is the minimum degree
    newNode->numKeys = t - 1;

    // Copy the last (t-1) keys of child to newNode
    for (int j = 0; j < t - 1; j++) {
        newNode->keys[j] = child->keys[j + t];
    }

    // If child is not a leaf, copy the last t children to newNode
    if (!child->isLeaf) {
        for (int j = 0; j < t; j++) {
            newNode->children[j] = child->children[j + t];
        }
    }

    // Reduce the number of keys in the original child
    child->numKeys = t - 1;

    // Shift children of parent to make room for new child
    for (int j = parent->numKeys; j >= i + 1; j--) {
        parent->children[j + 1] = parent->children[j];
    }
    parent->children[i + 1] = newNode;

    // Shift keys of parent to make room for the middle key of child
    for (int j = parent->numKeys - 1; j >= i; j--) {
        parent->keys[j + 1] = parent->keys[j];
    }
    parent->keys[i] = child->keys[t - 1];

    // Increment the number of keys in parent
    parent->numKeys++;
}

// Function to insert a new key into a non-full node
void insertNonFull(struct BTreeNode *node, int key) {
    int i = node->numKeys - 1;

    // If the node is a leaf
    if (node->isLeaf) {
        // Shift keys greater than key to make space
        while (i >= 0 && node->keys[i] > key) {
            node->keys[i + 1] = node->keys[i];
            i--;
        }
        node->keys[i + 1] = key;
        node->numKeys++;
    } else {
        // Find the child which is going to have the new key
        while (i >= 0 && node->keys[i] > key) {
            i--;
        }
        i++;

        // If the child is full, split it
        if (node->children[i]->numKeys == ORDER - 1) {
            splitChild(node, i, node->children[i]);

            // After split, the middle key of the child is moved up
            if (node->keys[i] < key) {
                i++;
            }
        }
        insertNonFull(node->children[i], key);
    }
}

// Function to insert a new key in the B-tree
void insert(struct BTreeNode **root, int key) {
    struct BTreeNode *r = *root;

    // If root is full, split it
    if (r->numKeys == ORDER - 1) {
        struct BTreeNode *newNode = createNode(0);
        newNode->children[0] = r;
        splitChild(newNode, 0, r);

        int i = 0;
        if (newNode->keys[0] < key) {
            i++;
        }
        insertNonFull(newNode->children[i], key);
        *root = newNode;
    } else {
        insertNonFull(r, key);
    }
}

// Function to print the B-tree structure
void printBTree(struct BTreeNode *node, int level) {
    if (node != NULL) {
        int i;
        for (i = 0; i < node->numKeys; i++) {
            printBTree(node->children[i], level + 1);
            for (int j = 0; j < level; j++) {
                printf("  ");
            }
            printf("%c\n", node->keys[i]);
        }
        printBTree(node->children[i], level + 1);
    }
}

int main() {
    struct BTreeNode *root = createNode(1);  // Create an empty B-tree with root as a leaf node

    // Array of keys to be inserted
    char keys[] = {'F', 'S', 'Q', 'K', 'C', 'L', 'H', 'T', 'V', 'W', 'M', 'R', 'N', 'P', 'A', 'B', 'X', 'Y', 'D', 'Z', 'E'};
    int n = sizeof(keys) / sizeof(keys[0]);

    // Insert each key into the B-tree
    for (int i = 0; i < n; i++) {
        insert(&root, keys[i]);
    }

    // Print the B-tree
    printf("B-tree of order %d:\n", ORDER);
    printBTree(root, 0);

    return 0;
}



2) DELETION OPERATION:

Necessary conditions before deleting any key from 
the B tree of degree m.
1. A node can have a maximum of m children.
2. A node can contain a maximum of m - 1 keys.
3. A node should have a minimum of ⌈m/2⌉ children.
4. A node (except root node) should contain a minimum 
of ⌈m/2⌉ - 1 keys.


1. Insertion of Keys
We already have the insert() function, so this part is straightforward. We just need to call this function to insert the new keys.


2. Deletion of Keys
We need to implement a function for deleting a key from the B-tree. This will involve:
Merging nodes when the number of keys in a node drops below the minimum allowed.
Borrowing keys from sibling nodes if possible, to maintain the required number of keys in the node.

CODE:


#include <stdio.h>
#include <stdlib.h>
#incldue <string>
#define ORDER 5

struct BTreeNode {
    int keys[ORDER - 1];
    struct BTreeNode *children[ORDER];
    int numKeys;
    int isLeaf;
};

struct BTreeNode *createNode(int isLeaf) {
    struct BTreeNode *newNode = (struct BTreeNode *)malloc(sizeof(struct BTreeNode));
    newNode->isLeaf = isLeaf;
    newNode->numKeys = 0;
    for (int i = 0; i < ORDER; i++) {
        newNode->children[i] = NULL;
    }
    return newNode;
}

void splitChild(struct BTreeNode *parent, int i, struct BTreeNode *child) {
    struct BTreeNode *newNode = createNode(child->isLeaf);
    newNode->numKeys = ORDER / 2 - 1;

    for (int j = 0; j < ORDER / 2 - 1; j++) {
        newNode->keys[j] = child->keys[j + ORDER / 2];
    }

    if (!child->isLeaf) {
        for (int j = 0; j < ORDER / 2; j++) {
            newNode->children[j] = child->children[j + ORDER / 2];
        }
    }

    child->numKeys = ORDER / 2 - 1;

    for (int j = parent->numKeys; j >= i; j--) {
        parent->children[j + 1] = parent->children[j];
    }
    parent->children[i + 1] = newNode;

    for (int j = parent->numKeys - 1; j >= i; j--) {
        parent->keys[j + 1] = parent->keys[j];
    }

    parent->keys[i] = child->keys[ORDER / 2 - 1];
    parent->numKeys++;
}

void insertNonFull(struct BTreeNode *node, int key) {
    int i = node->numKeys - 1;

    if (node->isLeaf) {
        while (i >= 0 && key < node->keys[i]) {
            node->keys[i + 1] = node->keys[i];
            i--;
        }
        node->keys[i + 1] = key;
        node->numKeys++;
    } else {
        while (i >= 0 && key < node->keys[i]) {
            i--;
        }
        i++;
        if (node->children[i]->numKeys == ORDER - 1) {
            splitChild(node, i, node->children[i]);
            if (key > node->keys[i]) {
                i++;
            }
        }
        insertNonFull(node->children[i], key);
    }
}

void insert(struct BTreeNode **root, int key) {
    struct BTreeNode *r = *root;

    if (r->numKeys == ORDER - 1) {
        struct BTreeNode *newNode = createNode(0);
        newNode->children[0] = r;
        splitChild(newNode, 0, r);
        insertNonFull(newNode, key);
        *root = newNode;
    } else {
        insertNonFull(r, key);
    }
}

int findKey(struct BTreeNode *node, int key) {
    int idx = 0;
    while (idx < node->numKeys && key > node->keys[idx]) {
        idx++;
    }
    return idx;
}

void removeFromLeaf(struct BTreeNode *node, int idx) {
    for (int i = idx; i < node->numKeys - 1; i++) {
        node->keys[i] = node->keys[i + 1];
    }
    node->numKeys--;
}

void removeFromNonLeaf(struct BTreeNode *node, int idx) {
    int key = node->keys[idx];
    if (node->children[idx]->numKeys >= ORDER / 2) {
        struct BTreeNode *cur = node->children[idx];
        while (!cur->isLeaf) {
            cur = cur->children[cur->numKeys];
        }
        int pred = cur->keys[cur->numKeys - 1];
        node->keys[idx] = pred;
        deleteKey(node->children[idx], pred);
    } else if (node->children[idx + 1]->numKeys >= ORDER / 2) {
        struct BTreeNode *cur = node->children[idx + 1];
        while (!cur->isLeaf) {
            cur = cur->children[0];
        }
        int succ = cur->keys[0];
        node->keys[idx] = succ;
        deleteKey(node->children[idx + 1], succ);
    } else {
        merge(node, idx);
        deleteKey(node->children[idx], key);
    }
}

void merge(struct BTreeNode *node, int idx) {
    struct BTreeNode *child = node->children[idx];
    struct BTreeNode *sibling = node->children[idx + 1];

    child->keys[ORDER / 2 - 1] = node->keys[idx];

    for (int i = 0; i < sibling->numKeys; i++) {
        child->keys[i + ORDER / 2] = sibling->keys[i];
    }

    if (!child->isLeaf) {
        for (int i = 0; i <= sibling->numKeys; i++) {
            child->children[i + ORDER / 2] = sibling->children[i];
        }
    }

    for (int i = idx + 1; i < node->numKeys; i++) {
        node->keys[i - 1] = node->keys[i];
    }

    for (int i = idx + 2; i <= node->numKeys; i++) {
        node->children[i - 1] = node->children[i];
    }

    child->numKeys += sibling->numKeys + 1;
    node->numKeys--;
    free(sibling);
}

void deleteKey(struct BTreeNode *node, int key) {
    int idx = findKey(node, key);

    if (idx < node->numKeys && node->keys[idx] == key) {
        if (node->isLeaf) {
            removeFromLeaf(node, idx);
        } else {
            removeFromNonLeaf(node, idx);
        }
    } else {
        if (node->isLeaf) {
            printf("The key %d is not in the tree\n", key);
            return;
        }

        int flag = (idx == node->numKeys) ? 1 : 0;

        if (node->children[idx]->numKeys < ORDER / 2) {
            fill(node, idx);
        }

        if (flag && idx > node->numKeys) {
            deleteKey(node->children[idx - 1], key);
        } else {
            deleteKey(node->children[idx], key);
        }
    }
}

void fill(struct BTreeNode *node, int idx) {
    if (idx != 0 && node->children[idx - 1]->numKeys >= ORDER / 2) {
        borrowFromPrev(node, idx);
    } else if (idx != node->numKeys && node->children[idx + 1]->numKeys >= ORDER / 2) {
        borrowFromNext(node, idx);
    } else {
        if (idx != node->numKeys) {
            merge(node, idx);
        } else {
            merge(node, idx - 1);
        }
    }
}

void borrowFromPrev(struct BTreeNode *node, int idx) {
    struct BTreeNode *child = node->children[idx];
    struct BTreeNode *sibling = node->children[idx - 1];

    for (int i = child->numKeys - 1; i >= 0; --i) {
        child->keys[i + 1] = child->keys[i];
    }
    if (!child->isLeaf) {
        for (int i = child->numKeys; i >= 0; --i) {
            child->children[i + 1] = child->children[i];
        }
    }

    child->keys[0] = node->keys[idx - 1];

    if (!child->isLeaf) {
        child->children[0] = sibling->children[sibling->numKeys];
    }

    node->keys[idx - 1] = sibling->keys[sibling->numKeys - 1];
    child->numKeys++;
    sibling->numKeys--;
}

void borrowFromNext(struct BTreeNode *node, int idx) {
    struct BTreeNode *child = node->children[idx];
    struct BTreeNode *sibling = node->children[idx + 1];

    child->keys[child->numKeys] = node->keys[idx];
    if (!child->isLeaf) {
        child->children[child->numKeys + 1] = sibling->children[0];
    }

    node->keys[idx] = sibling->keys[0];

    for (int i = 1; i < sibling->numKeys; ++i) {
        sibling->keys[i - 1] = sibling->keys[i];
    }
    if (!sibling->isLeaf) {
        for (int i = 1; i <= sibling->numKeys; ++i) {
            sibling->children[i - 1] = sibling->children[i];
        }
    }

    child->numKeys++;
    sibling->numKeys--;
}

void printBTree(struct BTreeNode *node, int level) {
    if (node != NULL) {
        int i;
        for (i = 0; i < node->numKeys; i++) {
            printBTree(node->children[i], level + 1);
            for (int j = 0; j < level; j++) {
                printf("    ");  // Indentation for levels
            }
            printf("%d\n", node->keys[i]);
        }
        printBTree(node->children[i], level + 1);
    }
}

int main() {
    struct BTreeNode *root = createNode(1);

    // Insert the initial set of keys into the B-tree
    int keys[] = {3, 7, 9, 23, 45, 1, 5, 14, 25, 24, 13, 11, 8, 19, 4, 31, 35, 56};
    int n = sizeof(keys) / sizeof(keys[0]);

    for (int i = 0; i < n; i++) {
        insert(&root, keys[i]);
    }

    // Insert the additional keys: 2, 6, 12
    insert(&root, 2);
    insert(&root, 6);
    insert(&root, 12);

    // Print the B-tree after inserting the new keys
    printf("B-tree after inserting 2, 6, 12:\n");
    printBTree(root, 0);

    // Delete the specified keys: 4, 5, 7, 3, 14
    deleteKey(root, 4);
    deleteKey(root, 5);
    deleteKey(root, 7);
    deleteKey(root, 3);
    deleteKey(root, 14);

    // Print the B-tree after deletion
    printf("\nB-tree after deleting 4, 5, 7, 3, 14:\n");
    printBTree(root, 0);

    return 0;
}

## During insertion, the key always goes into a leaf. For deletion 
we wish to remove from a leaf ##

## ANALYSIS OF B-TREE ##

Max.no of items in a B-Tree of order m and height h is:

m^(h+1) - 1;



## B + TREE BUT ONLY DATA PART AND NOT THE ACTUAL PART ##

In B+ tree, 
– Records (data) can only be stored on the leaf nodes while 
internal nodes can only store the key values
– The internal nodes of B+ tree are often called index nodes. 
– The leaf nodes of a B+ tree are linked together in the form 
of a singly linked lists to make the search queries more 
efficient

• Size of main memory is always limited, therefore
– Internal nodes (keys to access records) of the B+ tree are 
stored in the main memory whereas, leaf nodes are stored 
in the secondary memory

## STRUCTURE OF A B+ TREE ##

** FOR ORDER A **
•Each internal node is of the form: <P1
, K1
, P2
, K2
, ….., Pc-1, Kc-1, Pc
> where c <= a and 
each Pi
 is a tree pointer (i.e points to another node of the tree) and, each Ki
 is a 
key-value (see diagram-I for reference)

** FOR ORDER B **

Each leaf node is of the form: <<K1
, D1>, <K2
, D2>, ….., <Kc-1, Dc-1>, Pnext> where c <= b 
and each Di
 is a data pointer (i.e points to actual record in the disk whose key value is 
Ki
 or to a disk file block containing that record) and, each Ki
 is a key 
value and, Pnext points to next leaf node in the B+ tree


## RED BLACK TREE ##

1) PROPERTIES OF RED BLACK TREE

A red-black tree satisfies the following properties:
1. Every node is either red or black.
2. The root is black.
3. Every leaf (denoted by NULL/NIL) is black.
4. If a node is red, then both its children are black.
5. For each node, all simple paths from the node to
descendant leaves contain the same number of black
nodes.


 Interesting points about Red-Black Tree
• Black height of the red-black tree
• No. of black nodes on a path from the root node to a
leaf node (excluding the root)
• A red-black tree of height h has black height >= h/2
• Height of a red-black tree with n nodes is h<= 2 log2
(n+1)
• All leaves (NIL) are black
• Black depth of a node
• No. of black nodes from the root to that node
• i.e the number of black ancestors
• Every red-black tree is a special case of a binary tree

SPECIAL CASES:
*RED NODE CANNOT HAVE RED CHILDREN
*EVERY PATH FROM A NODE TO ITS DESCENDANT LEAVES MUST HAVE THE SAME NUMEBR OF BLACK NODES

CASES DURING INSERTION OF NODES:

1. If tree is empty then
 create newNode as a Root node with
Black color

2. If Tree is not empty then Insert
newNode with Red color

3. If the parent of newNode is Black
then exit.

4. If Parent of newNode is Red then
check the color of parent's sibling of
newNode.(red-red violation)

5. If it's color is Black or Null Node
then perform rotations and then recolor.

6. If it's color is Red then recolor. 

COMPULSARY CASE TO FOLLOW:

1. Root is always black

2. No two adjacent Red nodes

3. No. of Black nodes in every
path are same

CODE:(INSERTION)



#include <stdio.h>
#include <stdlib.h>

enum Color { RED, BLACK };

struct node {
    int data;
    enum Color color;
    struct node* left;
    struct node* right;
    struct node* parent;
};

// Function to create a new node
struct node* createNode(int data) {
    struct node* newNode = (struct node*)malloc(sizeof(struct node));
    newNode->data = data;
    newNode->color = RED; // New nodes are inserted as red
    newNode->left = newNode->right = newNode->parent = NULL;
    return newNode;
}

// Left rotation
void leftRotate(struct node** root, struct node* x) {
    struct node* y = x->right;
    x->right = y->left;
    if (y->left != NULL) {
        y->left->parent = x;
    }
    y->parent = x->parent;
    if (x->parent == NULL) {
        *root = y;
    } else if (x == x->parent->left) {
        x->parent->left = y;
    } else {
        x->parent->right = y;
    }
    y->left = x;
    x->parent = y;
}

// Right rotation
void rightRotate(struct node** root, struct node* y) {
    struct node* x = y->left;
    y->left = x->right;
    if (x->right != NULL) {
        x->right->parent = y;
    }
    x->parent = y->parent;
    if (y->parent == NULL) {
        *root = x;
    } else if (y == y->parent->right) {
        y->parent->right = x;
    } else {
        y->parent->left = x;
    }
    x->right = y;
    y->parent = x;
}

// Function to fix violations after insertion
void insertFixup(struct node** root, struct node* z) {
    while (z != *root && z->parent->color == RED) {
        if (z->parent == z->parent->parent->left) {
            struct node* y = z->parent->parent->right; // Uncle
            if (y != NULL && y->color == RED) { // Case 1: Uncle is red
                z->parent->color = BLACK;
                y->color = BLACK;
                z->parent->parent->color = RED;
                z = z->parent->parent;
            } else { // Case 2 and 3
                if (z == z->parent->right) { // Case 2: z is right child
                    z = z->parent;
                    leftRotate(root, z);
                }
                // Case 3: z is left child
                z->parent->color = BLACK;
                z->parent->parent->color = RED;
                rightRotate(root, z->parent->parent);
            }
        } else { // Symmetric case: z->parent is the right child
            struct node* y = z->parent->parent->left;
            if (y != NULL && y->color == RED) { // Case 1: Uncle is red
                z->parent->color = BLACK;
                y->color = BLACK;
                z->parent->parent->color = RED;
                z = z->parent->parent;
            } else { // Case 2 and 3
                if (z == z->parent->left) { // Case 2: z is left child
                    z = z->parent;
                    rightRotate(root, z);
                }
                // Case 3: z is right child
                z->parent->color = BLACK;
                z->parent->parent->color = RED;
                leftRotate(root, z->parent->parent);
            }
        }
    }
    (*root)->color = BLACK; // Ensure the root is always black
}

// Function to insert a new node into the Red-Black Tree
void insert(struct node** root, int data) {
    struct node* newNode = createNode(data);
    struct node* y = NULL;
    struct node* x = *root;

    while (x != NULL) {
        y = x;
        if (newNode->data < x->data) {
            x = x->left;
        } else {
            x = x->right;
        }
    }

    newNode->parent = y;
    if (y == NULL) {
        *root = newNode;
    } else if (newNode->data < y->data) {
        y->left = newNode;
    } else {
        y->right = newNode;
    }

    insertFixup(root, newNode);  // Fix any violations after insertion
}

// Function to do inorder traversal of the tree
void inorder(struct node* root) {
    if (root == NULL)
        return;
    inorder(root->left);
    printf("%d ", root->data);
    inorder(root->right);
}

// Function to print the tree structure
void printTree(struct node* root, int depth) {
    if (root == NULL)
        return;

    printTree(root->right, depth + 1);
    for (int i = 0; i < depth; i++) {
        printf("   ");
    }
    printf("%d(%s)\n", root->data, root->color == RED ? "R" : "B");
    printTree(root->left, depth + 1);
}

int main() {
    struct node* root = NULL;

    // Inserting keys into the Red-Black Tree
    int keys[] = {10, 5, 15, 3, 7, 13, 18, 1, 4, 6, 8, 12, 16, 20};
    int n = sizeof(keys) / sizeof(keys[0]);

    for (int i = 0; i < n; i++) {
        insert(&root, keys[i]);
        printf("Inorder traversal after inserting %d: ", keys[i]);
        inorder(root);
        printf("\nTree structure after inserting %d:\n", keys[i]);
        printTree(root, 0);
        printf("\n");
    }
    return 0;
}


## Deletion in RB Tree ##

Recall the rules for BST deletion

1. If vertex to be deleted is a leaf, just delete it.

2. If vertex to be deleted has just one child,
replace it with that child

3. If vertex to be deleted has two children,
replace the value of by it’s in-order
predecessor’s value then delete the in-order
predecessor (a recursive step)


What can go wrong?
1. If the deleted node is RED?
Not a problem – no RB properties violated

2. If the deleted node is BLACK?

If the node is not the root, deleting it will 
change the black-height along some path

Simple Case: If either u or v is red

If Both u and v are Black.
Color u as double black. Now our task reduces to convert this double
black to single black. 

Note that If v is leaf, then u is NULL and color of
NULL is considered black. So the deletion of a black leaf also causes a
double black.


If sibling is black and its both children are black, perform recoloring, and
recur for the parent if parent is black

In this case, if parent was red, then we didn’t need to recur for parent, we can
simply make it black (red + double black = single black)

(c): If sibling is red, perform a rotation to move old sibling up, recolor the old
sibling and parent. The new sibling is always black (See the below diagram). This
mainly converts the tree to black sibling case (by rotation) and leads to case (a) or
(b).

This case can be divided in two subcases.
(i) Left Case (s is left child of its parent). This is mirror of right right case shown in 
below diagram. We right rotate the parent p.

(ii) Right Case (s is right child of its parent). We left rotate the parent p.
If u is root, make it single black and return (Black height of complete tree reduces
by 1).


## DELETIONS ##


Steps in Red-Black Tree Deletion:
Perform a BST deletion:

First, the node to be deleted is removed using the same approach as in a BST (replacing it with its in-order successor if it has two children, or removing it directly if it has one or no children).
Fixing violations:

After the deletion, Red-Black Tree properties might be violated, particularly regarding the black height or red-red violations.
These violations are fixed by performing a series of rotations and recoloring operations.
Two main cases to handle:

Case 1: Deleted node was red:
No further action is needed since removing a red node doesn’t affect the black height.
Case 2: Deleted node was black:
This is the more complicated case because it disrupts the black height balance. The tree needs to fix the "double black" issue.
The fix involves several cases that depend on the color and structure of the deleted node's sibling and parent.
Fixing Double Black (when deleting a black node):
If a black node is deleted, the resulting tree may have a "double black" node (an extra black depth) that needs to be corrected:

Case 1: Sibling is red:

If the sibling is red, rotate the parent and recolor the parent and sibling. This transforms it into a simpler situation where the sibling is black.
Case 2: Sibling is black with black children:

Recolor the sibling as red, and move the "double black" problem up to the parent. If the parent was red, recolor it black; otherwise, continue fixing at the parent level.
Case 3: Sibling is black with at least one red child:

If the sibling has a red child, perform rotations (left or right) to balance the tree. Depending on the case, you may need to rotate the sibling and parent to restore the Red-Black properties.
Case 4: Sibling is black with a red child farthest from the double black:

A left-right or right-left rotation will be needed, followed by recoloring.
Example of Rotations and Recoloring:
Left Rotation: When a node's right child becomes its parent and the node itself becomes the left child.
Right Rotation: When a node's left child becomes its parent and the node itself becomes the right child.
Recoloring adjusts the colors of the nodes to restore the Red-Black properties (e.g., making the root black after a violation).


CODE: (DELETION)


#include <stdio.h>
#include <stdlib.h>

enum Color { RED, BLACK };

struct node {
    int data;
    enum Color color;
    struct node *left, *right, *parent;
};

struct node* createNode(int data) {
    struct node* newNode = (struct node*)malloc(sizeof(struct node));
    newNode->data = data;
    newNode->color = RED;
    newNode->left = newNode->right = newNode->parent = NULL;
    return newNode;
}

void leftRotate(struct node** root, struct node* x) {
    struct node* y = x->right;
    x->right = y->left;
    if (y->left != NULL) {
        y->left->parent = x;
    }
    y->parent = x->parent;
    if (x->parent == NULL) {
        *root = y;
    } else if (x == x->parent->left) {
        x->parent->left = y;
    } else {
        x->parent->right = y;
    }
    y->left = x;
    x->parent = y;
}


void rightRotate(struct node** root, struct node* y) {
    struct node* x = y->left;
    y->left = x->right;
    if (x->right != NULL) {
        x->right->parent = y;
    }
    x->parent = y->parent;
    if (y->parent == NULL) {
        *root = x;
    } else if (y == y->parent->right) {
        y->parent->right = x;
    } else {
        y->parent->left = x;
    }
    x->right = y;
    y->parent = x;
}

void insertFixup(struct node** root, struct node* z) {
    while (z != *root && z->parent->color == RED) {
        if (z->parent == z->parent->parent->left) {
            struct node* y = z->parent->parent->right;
            if (y != NULL && y->color == RED) {
                z->parent->color = BLACK;
                y->color = BLACK;
                z->parent->parent->color = RED;
                z = z->parent->parent;
            } else {
                if (z == z->parent->right) {
                    z = z->parent;
                    leftRotate(root, z);
                }
                z->parent->color = BLACK;
                z->parent->parent->color = RED;
                rightRotate(root, z->parent->parent);
            }
        } else {
            struct node* y = z->parent->parent->left;
            if (y != NULL && y->color == RED) {
                z->parent->color = BLACK;
                y->color = BLACK;
                z->parent->parent->color = RED;
                z = z->parent->parent;
            } else {
                if (z == z->parent->left) {
                    z = z->parent;
                    rightRotate(root, z);
                }
                z->parent->color = BLACK;
                z->parent->parent->color = RED;
                leftRotate(root, z->parent->parent);
            }
        }
    }
    (*root)->color = BLACK;
}

void insert(struct node** root, int data) {
    struct node* newNode = createNode(data);
    struct node* y = NULL;
    struct node* x = *root;
    while (x != NULL) {
        y = x;
        if (newNode->data < x->data) {
            x = x->left;
        } else {
            x = x->right;
        }
    }
    newNode->parent = y;
    if (y == NULL) {
        *root = newNode;
    } else if (newNode->data < y->data) {
        y->left = newNode;
    } else {
        y->right = newNode;
    }
    newNode->color = RED;
    insertFixup(root, newNode);
}

void transplant(struct node** root, struct node* u, struct node* v) {
    if (u->parent == NULL) {
        *root = v;
    } else if (u == u->parent->left) {
        u->parent->left = v;
    } else {
        u->parent->right = v;
    }
    if (v != NULL) {
        v->parent = u->parent;
    }
}

struct node* minimum(struct node* node) {
    while (node->left != NULL) {
        node = node->left;
    }
    return node;
}


void deleteFixup(struct node** root, struct node* x) {
    while (x != *root && (x == NULL || x->color == BLACK)) {
        if (x == x->parent->left) {
            struct node* w = x->parent->right;
            if (w->color == RED) {
                w->color = BLACK;
                x->parent->color = RED;
                leftRotate(root, x->parent);
                w = x->parent->right;
            }
            if ((w->left == NULL || w->left->color == BLACK) &&
                (w->right == NULL || w->right->color == BLACK)) {
                w->color = RED;
                x = x->parent;
            } else {
                if (w->right == NULL || w->right->color == BLACK) {
                    if (w->left != NULL) w->left->color = BLACK;
                    w->color = RED;
                    rightRotate(root, w);
                    w = x->parent->right;
                }
                w->color = x->parent->color;
                x->parent->color = BLACK;
                if (w->right != NULL) w->right->color = BLACK;
                leftRotate(root, x->parent);
                x = *root;
            }
        } else {
            struct node* w = x->parent->left;
            if (w->color == RED) {
                w->color = BLACK;
                x->parent->color = RED;
                rightRotate(root, x->parent);
                w = x->parent->left;
            }
            if ((w->right == NULL || w->right->color == BLACK) &&
                (w->left == NULL || w->left->color == BLACK)) {
                w->color = RED;
                x = x->parent;
            } else {
                if (w->left == NULL || w->left->color == BLACK) {
                    if (w->right != NULL) w->right->color = BLACK;
                    w->color = RED;
                    leftRotate(root, w);
                    w = x->parent->left;
                }
                w->color = x->parent->color;
                x->parent->color = BLACK;
                if (w->left != NULL) w->left->color = BLACK;
                rightRotate(root, x->parent);
                x = *root;
            }
        }
    }
    if (x != NULL) x->color = BLACK;
}

void deleteNode(struct node** root, struct node* z) {
    struct node* y = z;
    struct node* x;
    enum Color y_original_color = y->color;

    if (z->left == NULL) {
        x = z->right;
        transplant(root, z, z->right);
    } else if (z->right == NULL) {
        x = z->left;
        transplant(root, z, z->left);
    } else {
        y = minimum(z->right);
        y_original_color = y->color;
        x = y->right;
        if (y->parent == z) {
            if (x != NULL) x->parent = y;
        } else {
            transplant(root, y, y->right);
            y->right = z->right;
            y->right->parent = y;
        }
        transplant(root, z, y);
        y->left = z->left;
        y->left->parent = y;
        y->color = z->color;
    }
    if (y_original_color == BLACK) {
        deleteFixup(root, x);
    }
}

void inorder(struct node* root) {
    if (root == NULL) return;
    inorder(root->left);
    printf("%d(%s) ", root->data, root->color == RED ? "R" : "B");
    inorder(root->right);
}

int main() {
    struct node* root = NULL;
    int keys[] = {10, 18, 7, 15, 16, 30, 25, 40, 60};
    int n = sizeof(keys) / sizeof(keys[0]);

    printf("Inserting nodes...\n");
    for (int i = 0; i < n; i++) {
        insert(&root, keys[i]);
        printf("Inorder traversal after inserting %d: ", keys[i]);
        inorder(root);
        printf("\n");
    }

    printf("\nDeleting node 15...\n");
    struct node* nodeToDelete = root->right->left; 
    deleteNode(&root, nodeToDelete);
    printf("Inorder traversal after deletion: ");
    inorder(root);
    printf("\n");

    return 0;
}

	
